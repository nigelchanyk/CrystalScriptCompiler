===== Viable Prefix Recognizer =====
START lalr_state [0]: {
  [goal ::= (*) import_declarations_opt top_level_sections_opt , {EOF }]
  [simple_import_declaration ::= (*) IMPORT name , {NEWLINE ENDOFFILE }]
  [import_declarations ::= (*) import_declaration terminators import_declarations , {EOF PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
  [import_declarations_opt ::= (*) , {EOF PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
  [import_declaration ::= (*) import_declaration_with_alias , {NEWLINE ENDOFFILE }]
  [import_declarations ::= (*) import_declaration terminators , {EOF PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
  [import_declaration_with_alias ::= (*) IMPORT name AS IDENTIFIER , {NEWLINE ENDOFFILE }]
  [import_declaration ::= (*) simple_import_declaration , {NEWLINE ENDOFFILE }]
  [import_declarations_opt ::= (*) import_declarations , {EOF PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
  [$START ::= (*) goal EOF , {EOF }]
}
transition on import_declarations_opt to state [7]
transition on import_declarations to state [6]
transition on import_declaration_with_alias to state [5]
transition on goal to state [4]
transition on IMPORT to state [3]
transition on import_declaration to state [2]
transition on simple_import_declaration to state [1]

-------------------
lalr_state [1]: {
  [import_declaration ::= simple_import_declaration (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [2]: {
  [terminator ::= (*) NEWLINE , {EOF IMPORT PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
  [import_declarations ::= import_declaration (*) terminators import_declarations , {EOF PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {EOF IMPORT PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
  [import_declarations ::= import_declaration (*) terminators , {EOF PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {EOF IMPORT PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {EOF IMPORT PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [540]

-------------------
lalr_state [3]: {
  [name ::= (*) qualified_name , {DOT AS NEWLINE ENDOFFILE }]
  [simple_import_declaration ::= IMPORT (*) name , {NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {DOT AS NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {DOT AS NEWLINE ENDOFFILE }]
  [import_declaration_with_alias ::= IMPORT (*) name AS IDENTIFIER , {NEWLINE ENDOFFILE }]
}
transition on qualified_name to state [35]
transition on IDENTIFIER to state [34]
transition on name to state [537]

-------------------
lalr_state [4]: {
  [$START ::= goal (*) EOF , {EOF }]
}
transition on EOF to state [536]

-------------------
lalr_state [5]: {
  [import_declaration ::= import_declaration_with_alias (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [6]: {
  [import_declarations_opt ::= import_declarations (*) , {EOF PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [7]: {
  [modifiers_opt ::= (*) modifiers , {CLASS INTERFACE }]
  [modifier ::= (*) PRIVATE , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE }]
  [interface_declaration ::= (*) modifiers_opt INTERFACE IDENTIFIER extends_interfaces_opt interface_body , {NEWLINE ENDOFFILE }]
  [top_level_sections ::= (*) top_level_section terminators , {EOF }]
  [modifier ::= (*) PUBLIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE }]
  [class_declaration ::= (*) modifiers_opt CLASS IDENTIFIER super_opt interfaces_opt class_body , {NEWLINE ENDOFFILE }]
  [top_level_sections_opt ::= (*) , {EOF }]
  [top_level_section ::= (*) class_declaration , {NEWLINE ENDOFFILE }]
  [modifiers ::= (*) modifier , {CLASS INTERFACE }]
  [modifier ::= (*) STATIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE }]
  [top_level_sections ::= (*) top_level_section terminators top_level_sections , {EOF }]
  [modifiers_opt ::= (*) , {CLASS INTERFACE }]
  [modifier ::= (*) PROTECTED , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE }]
  [top_level_sections_opt ::= (*) top_level_sections , {EOF }]
  [top_level_section ::= (*) interface_declaration , {NEWLINE ENDOFFILE }]
  [modifiers ::= (*) modifier modifiers , {CLASS INTERFACE }]
  [goal ::= import_declarations_opt (*) top_level_sections_opt , {EOF }]
  [modifier ::= (*) ABSTRACT , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE }]
  [top_level_section ::= (*) , {NEWLINE ENDOFFILE }]
}
transition on modifiers_opt to state [20]
transition on class_declaration to state [19]
transition on top_level_sections to state [18]
transition on modifiers to state [17]
transition on interface_declaration to state [16]
transition on PRIVATE to state [15]
transition on top_level_section to state [14]
transition on PROTECTED to state [13]
transition on modifier to state [12]
transition on STATIC to state [11]
transition on PUBLIC to state [10]
transition on top_level_sections_opt to state [9]
transition on ABSTRACT to state [8]

-------------------
lalr_state [8]: {
  [modifier ::= ABSTRACT (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER }]
}

-------------------
lalr_state [9]: {
  [goal ::= import_declarations_opt top_level_sections_opt (*) , {EOF }]
}

-------------------
lalr_state [10]: {
  [modifier ::= PUBLIC (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER }]
}

-------------------
lalr_state [11]: {
  [modifier ::= STATIC (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER }]
}

-------------------
lalr_state [12]: {
  [modifier ::= (*) STATIC , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER }]
  [modifier ::= (*) PUBLIC , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER }]
  [modifiers ::= modifier (*) modifiers , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [modifier ::= (*) PRIVATE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER }]
  [modifiers ::= (*) modifier modifiers , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [modifier ::= (*) ABSTRACT , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER }]
  [modifier ::= (*) PROTECTED , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER }]
  [modifiers ::= modifier (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [modifiers ::= (*) modifier , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
}
transition on PRIVATE to state [15]
transition on PUBLIC to state [10]
transition on ABSTRACT to state [8]
transition on STATIC to state [11]
transition on modifiers to state [535]
transition on PROTECTED to state [13]
transition on modifier to state [12]

-------------------
lalr_state [13]: {
  [modifier ::= PROTECTED (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER }]
}

-------------------
lalr_state [14]: {
  [terminator ::= (*) NEWLINE , {EOF PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
  [top_level_sections ::= top_level_section (*) terminators top_level_sections , {EOF }]
  [terminators ::= (*) terminator terminators , {EOF PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
  [top_level_sections ::= top_level_section (*) terminators , {EOF }]
  [terminator ::= (*) ENDOFFILE , {EOF PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {EOF PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [533]

-------------------
lalr_state [15]: {
  [modifier ::= PRIVATE (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER }]
}

-------------------
lalr_state [16]: {
  [top_level_section ::= interface_declaration (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [17]: {
  [modifiers_opt ::= modifiers (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
}

-------------------
lalr_state [18]: {
  [top_level_sections_opt ::= top_level_sections (*) , {EOF }]
}

-------------------
lalr_state [19]: {
  [top_level_section ::= class_declaration (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [20]: {
  [class_declaration ::= modifiers_opt (*) CLASS IDENTIFIER super_opt interfaces_opt class_body , {NEWLINE ENDOFFILE }]
  [interface_declaration ::= modifiers_opt (*) INTERFACE IDENTIFIER extends_interfaces_opt interface_body , {NEWLINE ENDOFFILE }]
}
transition on CLASS to state [22]
transition on INTERFACE to state [21]

-------------------
lalr_state [21]: {
  [interface_declaration ::= modifiers_opt INTERFACE (*) IDENTIFIER extends_interfaces_opt interface_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [511]

-------------------
lalr_state [22]: {
  [class_declaration ::= modifiers_opt CLASS (*) IDENTIFIER super_opt interfaces_opt class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [23]

-------------------
lalr_state [23]: {
  [class_declaration ::= modifiers_opt CLASS IDENTIFIER (*) super_opt interfaces_opt class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [super_opt ::= (*) super_cl , {LBRACE IMPLEMENTS }]
  [super_opt ::= (*) , {LBRACE IMPLEMENTS }]
  [super_cl ::= (*) EXTENDS class_type , {LBRACE IMPLEMENTS }]
}
transition on super_cl to state [26]
transition on super_opt to state [25]
transition on EXTENDS to state [24]

-------------------
lalr_state [24]: {
  [name ::= (*) qualified_name , {DOT LBRACE IMPLEMENTS }]
  [class_type ::= (*) class_or_interface_type , {LBRACE IMPLEMENTS }]
  [name ::= (*) IDENTIFIER , {DOT LBRACE IMPLEMENTS }]
  [class_or_interface_type ::= (*) name , {LBRACE IMPLEMENTS }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {DOT LBRACE IMPLEMENTS }]
  [super_cl ::= EXTENDS (*) class_type , {LBRACE IMPLEMENTS }]
}
transition on class_type to state [510]
transition on qualified_name to state [35]
transition on IDENTIFIER to state [34]
transition on class_or_interface_type to state [509]
transition on name to state [31]

-------------------
lalr_state [25]: {
  [interfaces_opt ::= (*) interfaces , {LBRACE }]
  [interfaces_opt ::= (*) , {LBRACE }]
  [interfaces ::= (*) IMPLEMENTS interface_type_list , {LBRACE }]
  [class_declaration ::= modifiers_opt CLASS IDENTIFIER super_opt (*) interfaces_opt class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on interfaces to state [29]
transition on IMPLEMENTS to state [28]
transition on interfaces_opt to state [27]

-------------------
lalr_state [26]: {
  [super_opt ::= super_cl (*) , {LBRACE IMPLEMENTS }]
}

-------------------
lalr_state [27]: {
  [class_body ::= (*) lbrace_multiline class_body_declarations_opt rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [class_declaration ::= modifiers_opt CLASS IDENTIFIER super_opt interfaces_opt (*) class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on lbrace_multiline to state [49]
transition on class_body to state [48]
transition on LBRACE to state [47]

-------------------
lalr_state [28]: {
  [interface_type ::= (*) class_or_interface_type , {COMMA LBRACE }]
  [name ::= (*) qualified_name , {DOT COMMA LBRACE }]
  [interface_type_list ::= (*) interface_type comma_multiline interface_type_list , {LBRACE }]
  [name ::= (*) IDENTIFIER , {DOT COMMA LBRACE }]
  [class_or_interface_type ::= (*) name , {COMMA LBRACE }]
  [interface_type_list ::= (*) interface_type , {LBRACE }]
  [interfaces ::= IMPLEMENTS (*) interface_type_list , {LBRACE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {DOT COMMA LBRACE }]
}
transition on qualified_name to state [35]
transition on IDENTIFIER to state [34]
transition on class_or_interface_type to state [33]
transition on interface_type to state [32]
transition on name to state [31]
transition on interface_type_list to state [30]

-------------------
lalr_state [29]: {
  [interfaces_opt ::= interfaces (*) , {LBRACE }]
}

-------------------
lalr_state [30]: {
  [interfaces ::= IMPLEMENTS interface_type_list (*) , {LBRACE }]
}

-------------------
lalr_state [31]: {
  [class_or_interface_type ::= name (*) , {LBRACK COMMA LBRACE LPAREN IMPLEMENTS }]
  [qualified_name ::= name (*) DOT IDENTIFIER , {LBRACK DOT COMMA LBRACE LPAREN IMPLEMENTS }]
}
transition on DOT to state [45]

-------------------
lalr_state [32]: {
  [comma_multiline ::= (*) COMMA terminators_opt , {IDENTIFIER }]
  [interface_type_list ::= interface_type (*) comma_multiline interface_type_list , {LBRACE }]
  [interface_type_list ::= interface_type (*) , {LBRACE }]
}
transition on comma_multiline to state [37]
transition on COMMA to state [36]

-------------------
lalr_state [33]: {
  [interface_type ::= class_or_interface_type (*) , {COMMA LBRACE }]
}

-------------------
lalr_state [34]: {
  [name ::= IDENTIFIER (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ LPAREN RPAREN COLON AS PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS IMPLEMENTS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [35]: {
  [name ::= qualified_name (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ LPAREN RPAREN COLON AS PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS IMPLEMENTS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [36]: {
  [terminator ::= (*) NEWLINE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [comma_multiline ::= COMMA (*) terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [42]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [37]: {
  [interface_type ::= (*) class_or_interface_type , {COMMA LBRACE }]
  [name ::= (*) qualified_name , {DOT COMMA LBRACE }]
  [interface_type_list ::= interface_type comma_multiline (*) interface_type_list , {LBRACE }]
  [interface_type_list ::= (*) interface_type comma_multiline interface_type_list , {LBRACE }]
  [name ::= (*) IDENTIFIER , {DOT COMMA LBRACE }]
  [class_or_interface_type ::= (*) name , {COMMA LBRACE }]
  [interface_type_list ::= (*) interface_type , {LBRACE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {DOT COMMA LBRACE }]
}
transition on qualified_name to state [35]
transition on IDENTIFIER to state [34]
transition on class_or_interface_type to state [33]
transition on interface_type to state [32]
transition on name to state [31]
transition on interface_type_list to state [38]

-------------------
lalr_state [38]: {
  [interface_type_list ::= interface_type comma_multiline interface_type_list (*) , {LBRACE }]
}

-------------------
lalr_state [39]: {
  [terminators_opt ::= terminators (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE LPAREN RPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF THIS SUPER INTERFACE IF SWITCH CASE DEFAULT DO WHILE FOR BREAK CONTINUE RETURN THROW TRY CATCH FINALLY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [40]: {
  [terminator ::= (*) NEWLINE , {EOF ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE LPAREN RPAREN IMPORT PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF THIS SUPER INTERFACE IF SWITCH CASE DEFAULT DO WHILE FOR BREAK CONTINUE RETURN THROW TRY CATCH FINALLY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= terminator (*) terminators , {EOF ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE LPAREN RPAREN IMPORT PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF THIS SUPER INTERFACE IF SWITCH CASE DEFAULT DO WHILE FOR BREAK CONTINUE RETURN THROW TRY CATCH FINALLY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {EOF ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE LPAREN RPAREN IMPORT PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF THIS SUPER INTERFACE IF SWITCH CASE DEFAULT DO WHILE FOR BREAK CONTINUE RETURN THROW TRY CATCH FINALLY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {EOF ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE LPAREN RPAREN IMPORT PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF THIS SUPER INTERFACE IF SWITCH CASE DEFAULT DO WHILE FOR BREAK CONTINUE RETURN THROW TRY CATCH FINALLY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= terminator (*) , {EOF ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE LPAREN RPAREN IMPORT PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF THIS SUPER INTERFACE IF SWITCH CASE DEFAULT DO WHILE FOR BREAK CONTINUE RETURN THROW TRY CATCH FINALLY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {EOF ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE LPAREN RPAREN IMPORT PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF THIS SUPER INTERFACE IF SWITCH CASE DEFAULT DO WHILE FOR BREAK CONTINUE RETURN THROW TRY CATCH FINALLY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [44]

-------------------
lalr_state [41]: {
  [terminator ::= ENDOFFILE (*) , {EOF ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE LPAREN RPAREN IMPORT PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF THIS SUPER INTERFACE IF SWITCH CASE DEFAULT DO WHILE FOR BREAK CONTINUE RETURN THROW TRY CATCH FINALLY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [42]: {
  [comma_multiline ::= COMMA terminators_opt (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [43]: {
  [terminator ::= NEWLINE (*) , {EOF ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE LPAREN RPAREN IMPORT PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF THIS SUPER INTERFACE IF SWITCH CASE DEFAULT DO WHILE FOR BREAK CONTINUE RETURN THROW TRY CATCH FINALLY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [44]: {
  [terminators ::= terminator terminators (*) , {EOF ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE LPAREN RPAREN IMPORT PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF THIS SUPER INTERFACE IF SWITCH CASE DEFAULT DO WHILE FOR BREAK CONTINUE RETURN THROW TRY CATCH FINALLY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [45]: {
  [qualified_name ::= name DOT (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON COMMA LBRACE RBRACE LPAREN RPAREN COLON AS PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS IMPLEMENTS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [46]

-------------------
lalr_state [46]: {
  [qualified_name ::= name DOT IDENTIFIER (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ LPAREN RPAREN COLON AS PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS IMPLEMENTS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [47]: {
  [terminator ::= (*) NEWLINE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR COMMA LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF THIS SUPER INTERFACE IF SWITCH CASE DEFAULT DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= LBRACE (*) terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR COMMA LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF THIS SUPER INTERFACE IF SWITCH CASE DEFAULT DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR COMMA LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF THIS SUPER INTERFACE IF SWITCH CASE DEFAULT DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR COMMA LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF THIS SUPER INTERFACE IF SWITCH CASE DEFAULT DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR COMMA LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF THIS SUPER INTERFACE IF SWITCH CASE DEFAULT DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [508]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [48]: {
  [class_declaration ::= modifiers_opt CLASS IDENTIFIER super_opt interfaces_opt class_body (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [49]: {
  [modifiers_opt ::= (*) modifiers , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [interface_declaration ::= (*) modifiers_opt INTERFACE IDENTIFIER extends_interfaces_opt interface_body , {NEWLINE ENDOFFILE }]
  [modifier ::= (*) PRIVATE , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT DEF IDENTIFIER }]
  [class_body_declarations ::= (*) class_body_declaration terminators , {RBRACE NEWLINE ENDOFFILE }]
  [class_member_declaration ::= (*) method_declaration , {NEWLINE ENDOFFILE }]
  [modifier ::= (*) PUBLIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT DEF IDENTIFIER }]
  [class_declaration ::= (*) modifiers_opt CLASS IDENTIFIER super_opt interfaces_opt class_body , {NEWLINE ENDOFFILE }]
  [class_body_declarations_opt ::= (*) , {RBRACE NEWLINE ENDOFFILE }]
  [class_body_declaration ::= (*) constructor_declaration , {NEWLINE ENDOFFILE }]
  [field_declaration ::= (*) modifiers_opt type variable_declarators , {NEWLINE ENDOFFILE }]
  [method_header ::= (*) modifiers_opt DEF method_declarator , {LBRACE }]
  [modifiers ::= (*) modifier , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [modifier ::= (*) STATIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT DEF IDENTIFIER }]
  [class_body_declarations ::= (*) class_body_declaration terminators class_body_declarations , {RBRACE NEWLINE ENDOFFILE }]
  [class_member_declaration ::= (*) class_declaration , {NEWLINE ENDOFFILE }]
  [method_declaration ::= (*) method_header block , {NEWLINE ENDOFFILE }]
  [constructor_declaration ::= (*) modifiers_opt constructor_declarator block , {NEWLINE ENDOFFILE }]
  [modifiers_opt ::= (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [modifier ::= (*) PROTECTED , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT DEF IDENTIFIER }]
  [class_body_declarations_opt ::= (*) class_body_declarations , {RBRACE NEWLINE ENDOFFILE }]
  [class_member_declaration ::= (*) field_declaration , {NEWLINE ENDOFFILE }]
  [modifiers ::= (*) modifier modifiers , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [modifier ::= (*) ABSTRACT , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT DEF IDENTIFIER }]
  [class_body ::= lbrace_multiline (*) class_body_declarations_opt rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_body_declaration ::= (*) class_member_declaration , {NEWLINE ENDOFFILE }]
  [class_member_declaration ::= (*) interface_declaration , {NEWLINE ENDOFFILE }]
  [method_header ::= (*) modifiers_opt type method_declarator , {LBRACE }]
}
transition on class_member_declaration to state [60]
transition on interface_declaration to state [59]
transition on ABSTRACT to state [8]
transition on field_declaration to state [58]
transition on modifiers_opt to state [57]
transition on class_body_declarations to state [56]
transition on class_body_declaration to state [55]
transition on PROTECTED to state [13]
transition on class_body_declarations_opt to state [54]
transition on STATIC to state [11]
transition on method_header to state [53]
transition on PUBLIC to state [10]
transition on class_declaration to state [52]
transition on PRIVATE to state [15]
transition on method_declaration to state [51]
transition on constructor_declaration to state [50]
transition on modifiers to state [17]
transition on modifier to state [12]

-------------------
lalr_state [50]: {
  [class_body_declaration ::= constructor_declaration (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [51]: {
  [class_member_declaration ::= method_declaration (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [52]: {
  [class_member_declaration ::= class_declaration (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [53]: {
  [method_declaration ::= method_header (*) block , {NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {NEWLINE ENDOFFILE }]
}
transition on block to state [507]
transition on lbrace_multiline to state [104]
transition on LBRACE to state [47]

-------------------
lalr_state [54]: {
  [terminator ::= (*) NEWLINE , {RBRACE NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RBRACE }]
  [terminators ::= (*) terminator terminators , {RBRACE }]
  [terminators_opt ::= (*) , {RBRACE }]
  [terminator ::= (*) ENDOFFILE , {RBRACE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RBRACE }]
  [class_body ::= lbrace_multiline class_body_declarations_opt (*) rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [rbrace_multiline ::= (*) terminators_opt RBRACE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on rbrace_multiline to state [506]
transition on terminators_opt to state [312]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [55]: {
  [terminator ::= (*) NEWLINE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [class_body_declarations ::= class_body_declaration (*) terminators class_body_declarations , {RBRACE NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [class_body_declarations ::= class_body_declaration (*) terminators , {RBRACE NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [504]

-------------------
lalr_state [56]: {
  [class_body_declarations_opt ::= class_body_declarations (*) , {RBRACE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [57]: {
  [constructor_declarator ::= (*) IDENTIFIER lparen_multiline formal_parameter_list_opt rparen_multiline explicit_constructor_invocation_opt , {LBRACE }]
  [interface_declaration ::= modifiers_opt (*) INTERFACE IDENTIFIER extends_interfaces_opt interface_body , {NEWLINE ENDOFFILE }]
  [type ::= (*) primitive_type , {IDENTIFIER }]
  [primitive_type ::= (*) BOOLEAN , {LBRACK IDENTIFIER }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT IDENTIFIER }]
  [class_declaration ::= modifiers_opt (*) CLASS IDENTIFIER super_opt interfaces_opt class_body , {NEWLINE ENDOFFILE }]
  [primitive_type ::= (*) NUMBER , {LBRACK IDENTIFIER }]
  [field_declaration ::= modifiers_opt (*) type variable_declarators , {NEWLINE ENDOFFILE }]
  [reference_type ::= (*) array_type , {IDENTIFIER }]
  [method_header ::= modifiers_opt (*) DEF method_declarator , {LBRACE }]
  [array_type ::= (*) name dims , {IDENTIFIER }]
  [type ::= (*) reference_type , {IDENTIFIER }]
  [primitive_type ::= (*) OBJECT , {LBRACK IDENTIFIER }]
  [name ::= (*) qualified_name , {LBRACK DOT IDENTIFIER }]
  [constructor_declaration ::= modifiers_opt (*) constructor_declarator block , {NEWLINE ENDOFFILE }]
  [primitive_type ::= (*) STRING , {LBRACK IDENTIFIER }]
  [class_or_interface_type ::= (*) name , {IDENTIFIER }]
  [array_type ::= (*) ARRAY , {IDENTIFIER }]
  [type ::= (*) VAR , {IDENTIFIER }]
  [reference_type ::= (*) class_or_interface_type , {IDENTIFIER }]
  [array_type ::= (*) primitive_type dims , {IDENTIFIER }]
  [method_header ::= modifiers_opt (*) type method_declarator , {LBRACE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT IDENTIFIER }]
}
transition on name to state [75]
transition on VAR to state [74]
transition on ARRAY to state [73]
transition on array_type to state [72]
transition on INTERFACE to state [21]
transition on qualified_name to state [35]
transition on primitive_type to state [71]
transition on DEF to state [70]
transition on NUMBER to state [69]
transition on reference_type to state [68]
transition on STRING to state [67]
transition on BOOLEAN to state [66]
transition on OBJECT to state [65]
transition on constructor_declarator to state [64]
transition on IDENTIFIER to state [63]
transition on class_or_interface_type to state [62]
transition on type to state [61]
transition on CLASS to state [22]

-------------------
lalr_state [58]: {
  [class_member_declaration ::= field_declaration (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [59]: {
  [class_member_declaration ::= interface_declaration (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [60]: {
  [class_body_declaration ::= class_member_declaration (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [61]: {
  [method_declarator ::= (*) IDENTIFIER lparen_multiline formal_parameter_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [variable_declarator_id ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR COMMA RBRACE EQ PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [variable_declarators ::= (*) variable_declarator COMMA variable_declarators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [variable_declarator ::= (*) variable_declarator_id EQ variable_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [method_header ::= modifiers_opt type (*) method_declarator , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [variable_declarators ::= (*) variable_declarator , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [field_declaration ::= modifiers_opt type (*) variable_declarators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [variable_declarator ::= (*) variable_declarator_id , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on variable_declarators to state [503]
transition on IDENTIFIER to state [502]
transition on variable_declarator to state [453]
transition on variable_declarator_id to state [452]
transition on method_declarator to state [501]

-------------------
lalr_state [62]: {
  [reference_type ::= class_or_interface_type (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [63]: {
  [constructor_declarator ::= IDENTIFIER (*) lparen_multiline formal_parameter_list_opt rparen_multiline explicit_constructor_invocation_opt , {LBRACE }]
  [name ::= IDENTIFIER (*) , {LBRACK DOT IDENTIFIER }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RPAREN IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on LPAREN to state [89]
transition on lparen_multiline to state [485]

-------------------
lalr_state [64]: {
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {NEWLINE ENDOFFILE }]
  [constructor_declaration ::= modifiers_opt constructor_declarator (*) block , {NEWLINE ENDOFFILE }]
}
transition on block to state [105]
transition on lbrace_multiline to state [104]
transition on LBRACE to state [47]

-------------------
lalr_state [65]: {
  [primitive_type ::= OBJECT (*) , {LBRACK IDENTIFIER }]
}

-------------------
lalr_state [66]: {
  [primitive_type ::= BOOLEAN (*) , {LBRACK IDENTIFIER }]
}

-------------------
lalr_state [67]: {
  [primitive_type ::= STRING (*) , {LBRACK IDENTIFIER }]
}

-------------------
lalr_state [68]: {
  [type ::= reference_type (*) , {IDENTIFIER }]
}

-------------------
lalr_state [69]: {
  [primitive_type ::= NUMBER (*) , {LBRACK IDENTIFIER }]
}

-------------------
lalr_state [70]: {
  [method_declarator ::= (*) IDENTIFIER lparen_multiline formal_parameter_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [method_header ::= modifiers_opt DEF (*) method_declarator , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [87]
transition on method_declarator to state [86]

-------------------
lalr_state [71]: {
  [lbrack_multiline ::= (*) LBRACK terminators_opt , {RBRACK NEWLINE ENDOFFILE }]
  [dims ::= (*) dims lbrack_multiline rbrack_multiline , {LBRACK IDENTIFIER }]
  [array_type ::= primitive_type (*) dims , {IDENTIFIER }]
  [dims ::= (*) lbrack_multiline rbrack_multiline , {LBRACK IDENTIFIER }]
  [type ::= primitive_type (*) , {IDENTIFIER }]
}
transition on dims to state [85]
transition on LBRACK to state [77]
transition on lbrack_multiline to state [76]

-------------------
lalr_state [72]: {
  [reference_type ::= array_type (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [73]: {
  [array_type ::= ARRAY (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [74]: {
  [type ::= VAR (*) , {IDENTIFIER }]
}

-------------------
lalr_state [75]: {
  [array_type ::= name (*) dims , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lbrack_multiline ::= (*) LBRACK terminators_opt , {RBRACK NEWLINE ENDOFFILE }]
  [dims ::= (*) dims lbrack_multiline rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_or_interface_type ::= name (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= name (*) DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dims ::= (*) lbrack_multiline rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on DOT to state [45]
transition on dims to state [78]
transition on LBRACK to state [77]
transition on lbrack_multiline to state [76]

-------------------
lalr_state [76]: {
  [terminator ::= (*) NEWLINE , {RBRACK NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RBRACK }]
  [rbrack_multiline ::= (*) terminators_opt RBRACK , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RBRACK }]
  [terminators_opt ::= (*) , {RBRACK }]
  [terminator ::= (*) ENDOFFILE , {RBRACK NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RBRACK }]
  [dims ::= lbrack_multiline (*) rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [81]
transition on rbrack_multiline to state [84]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [77]: {
  [terminator ::= (*) NEWLINE , {RBRACK NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RBRACK LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RBRACK LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [lbrack_multiline ::= LBRACK (*) terminators_opt , {RBRACK LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {RBRACK LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {RBRACK NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RBRACK LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [83]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [78]: {
  [array_type ::= name dims (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dims ::= dims (*) lbrack_multiline rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lbrack_multiline ::= (*) LBRACK terminators_opt , {RBRACK NEWLINE ENDOFFILE }]
}
transition on LBRACK to state [77]
transition on lbrack_multiline to state [79]

-------------------
lalr_state [79]: {
  [terminator ::= (*) NEWLINE , {RBRACK NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RBRACK }]
  [rbrack_multiline ::= (*) terminators_opt RBRACK , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dims ::= dims lbrack_multiline (*) rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RBRACK }]
  [terminators_opt ::= (*) , {RBRACK }]
  [terminator ::= (*) ENDOFFILE , {RBRACK NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RBRACK }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [81]
transition on rbrack_multiline to state [80]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [80]: {
  [dims ::= dims lbrack_multiline rbrack_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [81]: {
  [rbrack_multiline ::= terminators_opt (*) RBRACK , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on RBRACK to state [82]

-------------------
lalr_state [82]: {
  [rbrack_multiline ::= terminators_opt RBRACK (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [83]: {
  [lbrack_multiline ::= LBRACK terminators_opt (*) , {RBRACK LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [84]: {
  [dims ::= lbrack_multiline rbrack_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [85]: {
  [array_type ::= primitive_type dims (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dims ::= dims (*) lbrack_multiline rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lbrack_multiline ::= (*) LBRACK terminators_opt , {RBRACK NEWLINE ENDOFFILE }]
}
transition on LBRACK to state [77]
transition on lbrack_multiline to state [79]

-------------------
lalr_state [86]: {
  [method_header ::= modifiers_opt DEF method_declarator (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [87]: {
  [lparen_multiline ::= (*) LPAREN terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RPAREN IDENTIFIER NEWLINE ENDOFFILE }]
  [method_declarator ::= IDENTIFIER (*) lparen_multiline formal_parameter_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on LPAREN to state [89]
transition on lparen_multiline to state [88]

-------------------
lalr_state [88]: {
  [formal_parameter_list ::= (*) formal_parameter , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [type ::= (*) primitive_type , {IDENTIFIER }]
  [primitive_type ::= (*) BOOLEAN , {LBRACK IDENTIFIER }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT IDENTIFIER }]
  [formal_parameter_list_opt ::= (*) , {RPAREN NEWLINE ENDOFFILE }]
  [formal_parameter ::= (*) variable_declarator_id , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [primitive_type ::= (*) NUMBER , {LBRACK IDENTIFIER }]
  [reference_type ::= (*) array_type , {IDENTIFIER }]
  [variable_declarator_id ::= (*) IDENTIFIER , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [array_type ::= (*) name dims , {IDENTIFIER }]
  [formal_parameter_list ::= (*) formal_parameter_list comma_multiline formal_parameter , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [type ::= (*) reference_type , {IDENTIFIER }]
  [primitive_type ::= (*) OBJECT , {LBRACK IDENTIFIER }]
  [name ::= (*) qualified_name , {LBRACK DOT IDENTIFIER }]
  [formal_parameter_list_opt ::= (*) formal_parameter_list , {RPAREN NEWLINE ENDOFFILE }]
  [primitive_type ::= (*) STRING , {LBRACK IDENTIFIER }]
  [class_or_interface_type ::= (*) name , {IDENTIFIER }]
  [method_declarator ::= IDENTIFIER lparen_multiline (*) formal_parameter_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [array_type ::= (*) ARRAY , {IDENTIFIER }]
  [formal_parameter ::= (*) type variable_declarator_id , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [type ::= (*) VAR , {IDENTIFIER }]
  [reference_type ::= (*) class_or_interface_type , {IDENTIFIER }]
  [array_type ::= (*) primitive_type dims , {IDENTIFIER }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT IDENTIFIER }]
}
transition on name to state [75]
transition on VAR to state [74]
transition on ARRAY to state [73]
transition on array_type to state [72]
transition on formal_parameter to state [96]
transition on qualified_name to state [35]
transition on primitive_type to state [71]
transition on variable_declarator_id to state [95]
transition on NUMBER to state [69]
transition on reference_type to state [68]
transition on formal_parameter_list_opt to state [94]
transition on STRING to state [67]
transition on BOOLEAN to state [66]
transition on OBJECT to state [65]
transition on formal_parameter_list to state [93]
transition on IDENTIFIER to state [92]
transition on class_or_interface_type to state [62]
transition on type to state [91]

-------------------
lalr_state [89]: {
  [terminator ::= (*) NEWLINE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RPAREN IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LPAREN RPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LPAREN RPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LPAREN RPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RPAREN IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= LPAREN (*) terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LPAREN RPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LPAREN RPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [90]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [90]: {
  [lparen_multiline ::= LPAREN terminators_opt (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LPAREN RPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [91]: {
  [formal_parameter ::= type (*) variable_declarator_id , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [variable_declarator_id ::= (*) IDENTIFIER , {COMMA RPAREN NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [103]
transition on variable_declarator_id to state [102]

-------------------
lalr_state [92]: {
  [variable_declarator_id ::= IDENTIFIER (*) , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [name ::= IDENTIFIER (*) , {LBRACK DOT IDENTIFIER }]
}

-------------------
lalr_state [93]: {
  [comma_multiline ::= (*) COMMA terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR IDENTIFIER }]
  [formal_parameter_list_opt ::= formal_parameter_list (*) , {RPAREN NEWLINE ENDOFFILE }]
  [formal_parameter_list ::= formal_parameter_list (*) comma_multiline formal_parameter , {COMMA RPAREN NEWLINE ENDOFFILE }]
}
transition on comma_multiline to state [100]
transition on COMMA to state [36]

-------------------
lalr_state [94]: {
  [terminator ::= (*) NEWLINE , {RPAREN NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RPAREN }]
  [terminators ::= (*) terminator terminators , {RPAREN }]
  [rparen_multiline ::= (*) terminators_opt RPAREN , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {RPAREN }]
  [terminator ::= (*) ENDOFFILE , {RPAREN NEWLINE ENDOFFILE }]
  [method_declarator ::= IDENTIFIER lparen_multiline formal_parameter_list_opt (*) rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RPAREN }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [98]
transition on rparen_multiline to state [97]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [95]: {
  [formal_parameter ::= variable_declarator_id (*) , {COMMA RPAREN NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [96]: {
  [formal_parameter_list ::= formal_parameter (*) , {COMMA RPAREN NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [97]: {
  [method_declarator ::= IDENTIFIER lparen_multiline formal_parameter_list_opt rparen_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [98]: {
  [rparen_multiline ::= terminators_opt (*) RPAREN , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on RPAREN to state [99]

-------------------
lalr_state [99]: {
  [rparen_multiline ::= terminators_opt RPAREN (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [100]: {
  [type ::= (*) primitive_type , {IDENTIFIER }]
  [primitive_type ::= (*) BOOLEAN , {LBRACK IDENTIFIER }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT IDENTIFIER }]
  [formal_parameter ::= (*) variable_declarator_id , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [primitive_type ::= (*) NUMBER , {LBRACK IDENTIFIER }]
  [reference_type ::= (*) array_type , {IDENTIFIER }]
  [variable_declarator_id ::= (*) IDENTIFIER , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [formal_parameter_list ::= formal_parameter_list comma_multiline (*) formal_parameter , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [array_type ::= (*) name dims , {IDENTIFIER }]
  [type ::= (*) reference_type , {IDENTIFIER }]
  [primitive_type ::= (*) OBJECT , {LBRACK IDENTIFIER }]
  [name ::= (*) qualified_name , {LBRACK DOT IDENTIFIER }]
  [primitive_type ::= (*) STRING , {LBRACK IDENTIFIER }]
  [class_or_interface_type ::= (*) name , {IDENTIFIER }]
  [array_type ::= (*) ARRAY , {IDENTIFIER }]
  [formal_parameter ::= (*) type variable_declarator_id , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [type ::= (*) VAR , {IDENTIFIER }]
  [reference_type ::= (*) class_or_interface_type , {IDENTIFIER }]
  [array_type ::= (*) primitive_type dims , {IDENTIFIER }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT IDENTIFIER }]
}
transition on array_type to state [72]
transition on IDENTIFIER to state [92]
transition on reference_type to state [68]
transition on type to state [91]
transition on formal_parameter to state [101]
transition on primitive_type to state [71]
transition on variable_declarator_id to state [95]
transition on qualified_name to state [35]
transition on VAR to state [74]
transition on STRING to state [67]
transition on class_or_interface_type to state [62]
transition on BOOLEAN to state [66]
transition on NUMBER to state [69]
transition on OBJECT to state [65]
transition on ARRAY to state [73]
transition on name to state [75]

-------------------
lalr_state [101]: {
  [formal_parameter_list ::= formal_parameter_list comma_multiline formal_parameter (*) , {COMMA RPAREN NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [102]: {
  [formal_parameter ::= type variable_declarator_id (*) , {COMMA RPAREN NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [103]: {
  [variable_declarator_id ::= IDENTIFIER (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE EQ RPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [104]: {
  [block_statement ::= (*) interface_declaration , {NEWLINE ENDOFFILE }]
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [modifier ::= (*) PROTECTED , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [primitive_type ::= (*) BOOLEAN , {LBRACK IDENTIFIER }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [if_then_statement ::= (*) IF expression terminators statement , {NEWLINE ENDOFFILE }]
  [array_type ::= (*) ARRAY , {IDENTIFIER }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [throw_statement ::= (*) THROW expression , {NEWLINE ENDOFFILE }]
  [block ::= lbrace_multiline (*) block_statements_opt rbrace_multiline , {ELSE WHILE CATCH FINALLY NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) do_statement , {NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [do_statement ::= (*) DO terminators_opt statement terminators_opt WHILE expression , {NEWLINE ENDOFFILE }]
  [expression_statement ::= (*) statement_expression , {NEWLINE ENDOFFILE }]
  [local_variable_declaration_statement ::= (*) local_variable_declaration , {NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [modifier ::= (*) PRIVATE , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [primitive_type ::= (*) OBJECT , {LBRACK IDENTIFIER }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement , {NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [try_statement ::= (*) TRY block terminators_opt catches , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) break_statement , {NEWLINE ENDOFFILE }]
  [block_statements_opt ::= (*) , {RBRACE NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) assignment , {NEWLINE ENDOFFILE }]
  [local_variable_declaration ::= (*) type variable_declarators , {NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [modifier ::= (*) STATIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [reference_type ::= (*) class_or_interface_type , {IDENTIFIER }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [try_statement ::= (*) TRY block terminators_opt catches terminators_opt finally , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) continue_statement , {NEWLINE ENDOFFILE }]
  [block_statements_opt ::= (*) block_statements , {RBRACE NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) preincrement_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) statement_without_trailing_substatement , {NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [modifier ::= (*) ABSTRACT , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [reference_type ::= (*) array_type , {IDENTIFIER }]
  [switch_statement ::= (*) SWITCH expression switch_block , {NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [try_statement ::= (*) TRY block terminators_opt finally , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) return_statement , {NEWLINE ENDOFFILE }]
  [block_statements ::= (*) block_statement terminators , {RBRACE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [modifiers_opt ::= (*) , {CLASS INTERFACE }]
  [type ::= (*) primitive_type , {IDENTIFIER }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) predecrement_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) labeled_statement , {NEWLINE ENDOFFILE }]
  [class_declaration ::= (*) modifiers_opt CLASS IDENTIFIER super_opt interfaces_opt class_body , {NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [class_or_interface_type ::= (*) name , {IDENTIFIER }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) throw_statement , {NEWLINE ENDOFFILE }]
  [block_statements ::= (*) block_statement terminators block_statements , {RBRACE NEWLINE ENDOFFILE }]
  [interface_declaration ::= (*) modifiers_opt INTERFACE IDENTIFIER extends_interfaces_opt interface_body , {NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [modifiers_opt ::= (*) modifiers , {CLASS INTERFACE }]
  [type ::= (*) reference_type , {IDENTIFIER }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postincrement_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_statement , {NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_without_trailing_substatement ::= (*) block , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) try_statement , {NEWLINE ENDOFFILE }]
  [block_statement ::= (*) local_variable_declaration_statement , {NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [modifiers ::= (*) modifier , {CLASS INTERFACE }]
  [type ::= (*) VAR , {IDENTIFIER }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postdecrement_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_else_statement , {NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [break_statement ::= (*) BREAK identifier_opt , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) empty_statement , {NEWLINE ENDOFFILE }]
  [empty_statement ::= (*) PASS , {NEWLINE ENDOFFILE }]
  [block_statement ::= (*) statement , {NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [modifiers ::= (*) modifier modifiers , {CLASS INTERFACE }]
  [primitive_type ::= (*) NUMBER , {LBRACK IDENTIFIER }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) method_invocation , {NEWLINE ENDOFFILE }]
  [statement ::= (*) while_statement , {NEWLINE ENDOFFILE }]
  [array_type ::= (*) primitive_type dims , {IDENTIFIER }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [continue_statement ::= (*) CONTINUE identifier_opt , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) expression_statement , {NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [while_statement ::= (*) WHILE expression terminators statement , {NEWLINE ENDOFFILE }]
  [labeled_statement ::= (*) IDENTIFIER colon_multiline statement , {NEWLINE ENDOFFILE }]
  [block_statement ::= (*) class_declaration , {NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [modifier ::= (*) PUBLIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [primitive_type ::= (*) STRING , {LBRACK IDENTIFIER }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) class_instance_creation_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) for_statement , {NEWLINE ENDOFFILE }]
  [array_type ::= (*) name dims , {IDENTIFIER }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [return_statement ::= (*) RETURN expression_opt , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) switch_statement , {NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
}
transition on do_statement to state [170]
transition on STATIC to state [11]
transition on PRIVATE to state [15]
transition on literal to state [169]
transition on statement to state [168]
transition on STRING to state [67]
transition on NEW to state [167]
transition on lparen_multiline to state [166]
transition on PLUSPLUS to state [165]
transition on qualified_name to state [35]
transition on primary_no_new_array to state [164]
transition on postincrement_expression to state [163]
transition on MINUSMINUS to state [162]
transition on throw_statement to state [161]
transition on IF to state [160]
transition on CONTINUE to state [159]
transition on if_then_else_statement to state [158]
transition on labeled_statement to state [157]
transition on predecrement_expression to state [156]
transition on continue_statement to state [155]
transition on modifiers_opt to state [20]
transition on primary to state [154]
transition on while_statement to state [153]
transition on assignment to state [152]
transition on block_statements_opt to state [151]
transition on primitive_type to state [71]
transition on lbrace_multiline to state [104]
transition on THIS to state [150]
transition on STRING_LITERAL to state [149]
transition on modifiers to state [17]
transition on NULL_LITERAL to state [148]
transition on name to state [147]
transition on BREAK to state [146]
transition on expression_statement to state [145]
transition on TRY to state [144]
transition on PUBLIC to state [10]
transition on RETURN to state [143]
transition on FOR to state [142]
transition on DO to state [141]
transition on SWITCH to state [140]
transition on statement_without_trailing_substatement to state [139]
transition on type to state [138]
transition on BOOLEAN to state [66]
transition on array_creation_expression to state [137]
transition on reference_type to state [68]
transition on WHILE to state [136]
transition on if_then_statement to state [135]
transition on ABSTRACT to state [8]
transition on SUPER to state [134]
transition on return_statement to state [133]
transition on empty_statement to state [132]
transition on NUMBER to state [69]
transition on preincrement_expression to state [131]
transition on local_variable_declaration to state [130]
transition on BOOLEAN_LITERAL to state [129]
transition on UNDEFINED_LITERAL to state [128]
transition on NUMBER_LITERAL to state [127]
transition on break_statement to state [126]
transition on local_variable_declaration_statement to state [125]
transition on VAR to state [74]
transition on OBJECT to state [65]
transition on ARRAY to state [73]
transition on interface_declaration to state [124]
transition on modifier to state [12]
transition on PROTECTED to state [13]
transition on field_access to state [123]
transition on postfix_expression to state [122]
transition on LPAREN to state [89]
transition on LBRACE to state [47]
transition on postdecrement_expression to state [121]
transition on block to state [120]
transition on class_instance_creation_expression to state [119]
transition on try_statement to state [118]
transition on statement_expression to state [117]
transition on THROW to state [116]
transition on PASS to state [115]
transition on array_type to state [72]
transition on class_declaration to state [114]
transition on left_hand_side to state [113]
transition on array_access to state [112]
transition on switch_statement to state [111]
transition on block_statement to state [110]
transition on class_or_interface_type to state [62]
transition on IDENTIFIER to state [109]
transition on method_invocation to state [108]
transition on for_statement to state [107]
transition on block_statements to state [106]

-------------------
lalr_state [105]: {
  [constructor_declaration ::= modifiers_opt constructor_declarator block (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [106]: {
  [block_statements_opt ::= block_statements (*) , {RBRACE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [107]: {
  [statement ::= for_statement (*) , {WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [108]: {
  [statement_expression ::= method_invocation (*) , {SEMICOLON COMMA ELSE WHILE NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= method_invocation (*) , {LBRACK DOT PLUSPLUS MINUSMINUS }]
}

-------------------
lalr_state [109]: {
  [labeled_statement ::= IDENTIFIER (*) colon_multiline statement , {WHILE NEWLINE ENDOFFILE }]
  [name ::= IDENTIFIER (*) , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [colon_multiline ::= (*) COLON terminators_opt , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on colon_multiline to state [484]
transition on COLON to state [290]

-------------------
lalr_state [110]: {
  [terminator ::= (*) NEWLINE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [block_statements ::= block_statement (*) terminators , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH CASE DEFAULT DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [block_statements ::= block_statement (*) terminators block_statements , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH CASE DEFAULT DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [482]

-------------------
lalr_state [111]: {
  [statement_without_trailing_substatement ::= switch_statement (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [112]: {
  [primary_no_new_array ::= array_access (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [left_hand_side ::= array_access (*) , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
}

-------------------
lalr_state [113]: {
  [assignment_operator ::= (*) OREQ , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment_operator ::= (*) URSHIFTEQ , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment_operator ::= (*) MINUSEQ , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment_operator ::= (*) DIVEQ , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment ::= left_hand_side (*) assignment_operator terminators_opt assignment_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment_operator ::= (*) XOREQ , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment_operator ::= (*) RSHIFTEQ , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment_operator ::= (*) PLUSEQ , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment_operator ::= (*) MULTEQ , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment_operator ::= (*) ANDEQ , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment_operator ::= (*) LSHIFTEQ , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment_operator ::= (*) MODEQ , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment_operator ::= (*) EQ , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on MODEQ to state [479]
transition on OREQ to state [478]
transition on assignment_operator to state [477]
transition on MINUSEQ to state [476]
transition on EQ to state [475]
transition on LSHIFTEQ to state [474]
transition on RSHIFTEQ to state [473]
transition on PLUSEQ to state [472]
transition on URSHIFTEQ to state [471]
transition on ANDEQ to state [470]
transition on DIVEQ to state [469]
transition on MULTEQ to state [468]
transition on XOREQ to state [467]

-------------------
lalr_state [114]: {
  [block_statement ::= class_declaration (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [115]: {
  [empty_statement ::= PASS (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [116]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT EQ ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [throw_statement ::= THROW (*) expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {ELSE WHILE ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT EQ ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT EQ LPAREN ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {ELSE WHILE ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT EQ ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT EQ LPAREN ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {ELSE WHILE OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT EQ ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {ELSE WHILE AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT EQ LPAREN ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {ELSE WHILE OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {ELSE WHILE AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {ELSE WHILE XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {ELSE WHILE XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {ELSE WHILE OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {ELSE WHILE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT EQ ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {ELSE WHILE OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on expression to state [466]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [117]: {
  [expression_statement ::= statement_expression (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [118]: {
  [statement_without_trailing_substatement ::= try_statement (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [119]: {
  [primary_no_new_array ::= class_instance_creation_expression (*) , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= class_instance_creation_expression (*) , {SEMICOLON COMMA ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [120]: {
  [statement_without_trailing_substatement ::= block (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [121]: {
  [statement_expression ::= postdecrement_expression (*) , {SEMICOLON COMMA ELSE WHILE NEWLINE ENDOFFILE }]
  [postfix_expression ::= postdecrement_expression (*) , {PLUSPLUS MINUSMINUS }]
}

-------------------
lalr_state [122]: {
  [postdecrement_expression ::= postfix_expression (*) MINUSMINUS , {SEMICOLON COMMA ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [postincrement_expression ::= postfix_expression (*) PLUSPLUS , {SEMICOLON COMMA ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
}
transition on PLUSPLUS to state [295]
transition on MINUSMINUS to state [294]

-------------------
lalr_state [123]: {
  [left_hand_side ::= field_access (*) , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= field_access (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [124]: {
  [block_statement ::= interface_declaration (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [125]: {
  [block_statement ::= local_variable_declaration_statement (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [126]: {
  [statement_without_trailing_substatement ::= break_statement (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [127]: {
  [literal ::= NUMBER_LITERAL (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [128]: {
  [literal ::= UNDEFINED_LITERAL (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [129]: {
  [literal ::= BOOLEAN_LITERAL (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [130]: {
  [local_variable_declaration_statement ::= local_variable_declaration (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [131]: {
  [statement_expression ::= preincrement_expression (*) , {SEMICOLON COMMA ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [132]: {
  [statement_without_trailing_substatement ::= empty_statement (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [133]: {
  [statement_without_trailing_substatement ::= return_statement (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [134]: {
  [method_invocation ::= SUPER (*) DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= SUPER (*) DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on DOT to state [461]

-------------------
lalr_state [135]: {
  [statement ::= if_then_statement (*) , {WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [136]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [while_statement ::= WHILE (*) expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on class_instance_creation_expression to state [196]
transition on conditional_or_expression to state [197]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on expression to state [459]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [137]: {
  [primary ::= array_creation_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [138]: {
  [variable_declarator_id ::= (*) IDENTIFIER , {SEMICOLON COMMA EQ NEWLINE ENDOFFILE }]
  [variable_declarators ::= (*) variable_declarator COMMA variable_declarators , {SEMICOLON NEWLINE ENDOFFILE }]
  [variable_declarator ::= (*) variable_declarator_id EQ variable_initializer , {SEMICOLON COMMA NEWLINE ENDOFFILE }]
  [local_variable_declaration ::= type (*) variable_declarators , {SEMICOLON NEWLINE ENDOFFILE }]
  [variable_declarators ::= (*) variable_declarator , {SEMICOLON NEWLINE ENDOFFILE }]
  [variable_declarator ::= (*) variable_declarator_id , {SEMICOLON COMMA NEWLINE ENDOFFILE }]
}
transition on variable_declarators to state [454]
transition on IDENTIFIER to state [103]
transition on variable_declarator to state [453]
transition on variable_declarator_id to state [452]

-------------------
lalr_state [139]: {
  [statement ::= statement_without_trailing_substatement (*) , {WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [140]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {LBRACE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {LBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT LBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [equality_expression ::= (*) relational_expression , {LBRACE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT LBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [expression ::= (*) assignment_expression , {LBRACE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {LBRACE ANDAND OROR QUESTION }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT LBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT LBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary ::= (*) array_creation_expression , {DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {LBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) primary , {MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {LBRACE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT LBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT LBRACE EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {LBRACE ANDAND OROR QUESTION }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT LBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT LBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {LBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) name , {MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {LBRACE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT LBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT LBRACE EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [conditional_or_expression ::= (*) conditional_and_expression , {LBRACE OROR QUESTION }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT LBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT LBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {LBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) postincrement_expression , {MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [switch_statement ::= SWITCH (*) expression switch_block , {ELSE WHILE NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {LBRACE AND XOR OR ANDAND OROR QUESTION }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT LBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT LBRACE EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {LBRACE OROR QUESTION }]
  [additive_expression ::= (*) multiplicative_expression , {LBRACE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {LBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {LBRACE AND XOR OR ANDAND OROR QUESTION }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT LBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [conditional_expression ::= (*) conditional_or_expression , {LBRACE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {LBRACE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {LBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {LBRACE XOR OR ANDAND OROR QUESTION }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT LBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {LBRACE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {LBRACE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {LBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {LBRACE XOR OR ANDAND OROR QUESTION }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT LBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [assignment_expression ::= (*) conditional_expression , {LBRACE }]
  [shift_expression ::= (*) additive_expression , {LBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {LBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) preincrement_expression , {MULT LBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {LBRACE OR ANDAND OROR QUESTION }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT LBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [assignment_expression ::= (*) assignment , {LBRACE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {LBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT LBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {LBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) predecrement_expression , {MULT LBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {LBRACE OR ANDAND OROR QUESTION }]
  [multiplicative_expression ::= (*) unary_expression , {MULT LBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary ::= (*) primary_no_new_array , {DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT LBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on expression to state [426]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [141]: {
  [do_statement ::= DO (*) terminators_opt statement terminators_opt WHILE expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [terminator ::= (*) NEWLINE , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [421]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [142]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {SEMICOLON COMMA }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primitive_type ::= (*) BOOLEAN , {LBRACK IDENTIFIER }]
  [array_type ::= (*) ARRAY , {IDENTIFIER }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [primitive_type ::= (*) OBJECT , {LBRACK IDENTIFIER }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [for_statement ::= FOR (*) for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) assignment , {SEMICOLON COMMA }]
  [local_variable_declaration ::= (*) type variable_declarators , {SEMICOLON }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS }]
  [reference_type ::= (*) class_or_interface_type , {IDENTIFIER }]
  [statement_expression_list ::= (*) statement_expression , {SEMICOLON COMMA }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) preincrement_expression , {SEMICOLON COMMA }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [reference_type ::= (*) array_type , {IDENTIFIER }]
  [statement_expression_list ::= (*) statement_expression_list comma_multiline statement_expression , {SEMICOLON COMMA }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {SEMICOLON COMMA }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [type ::= (*) primitive_type , {IDENTIFIER }]
  [for_init_opt ::= (*) , {SEMICOLON }]
  [statement_expression ::= (*) predecrement_expression , {SEMICOLON COMMA }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [class_or_interface_type ::= (*) name , {IDENTIFIER }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {SEMICOLON COMMA }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS }]
  [type ::= (*) reference_type , {IDENTIFIER }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_init_opt ::= (*) for_init , {SEMICOLON }]
  [statement_expression ::= (*) postincrement_expression , {SEMICOLON COMMA }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {SEMICOLON COMMA PLUSPLUS MINUSMINUS }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [type ::= (*) VAR , {IDENTIFIER }]
  [for_init ::= (*) statement_expression_list , {SEMICOLON }]
  [statement_expression ::= (*) postdecrement_expression , {SEMICOLON COMMA }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {SEMICOLON COMMA PLUSPLUS MINUSMINUS }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primitive_type ::= (*) NUMBER , {LBRACK IDENTIFIER }]
  [for_init ::= (*) local_variable_declaration , {SEMICOLON }]
  [statement_expression ::= (*) method_invocation , {SEMICOLON COMMA }]
  [array_type ::= (*) primitive_type dims , {IDENTIFIER }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primitive_type ::= (*) STRING , {LBRACK IDENTIFIER }]
  [statement_expression ::= (*) class_instance_creation_expression , {SEMICOLON COMMA }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [array_type ::= (*) name dims , {IDENTIFIER }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
}
transition on type to state [138]
transition on IDENTIFIER to state [34]
transition on for_init to state [372]
transition on VAR to state [74]
transition on array_access to state [112]
transition on class_or_interface_type to state [62]
transition on for_init_opt to state [415]
transition on STRING to state [67]
transition on preincrement_expression to state [131]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [108]
transition on primary_no_new_array to state [164]
transition on reference_type to state [68]
transition on class_instance_creation_expression to state [119]
transition on primitive_type to state [71]
transition on postfix_expression to state [122]
transition on NUMBER to state [69]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [121]
transition on BOOLEAN to state [66]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on primary to state [154]
transition on statement_expression_list to state [370]
transition on assignment to state [152]
transition on OBJECT to state [65]
transition on lparen_multiline to state [166]
transition on array_type to state [72]
transition on local_variable_declaration to state [369]
transition on name to state [147]
transition on BOOLEAN_LITERAL to state [129]
transition on ARRAY to state [73]
transition on array_creation_expression to state [137]
transition on predecrement_expression to state [156]
transition on literal to state [169]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [163]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]
transition on statement_expression to state [368]

-------------------
lalr_state [143]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT EQ ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {ELSE WHILE ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT EQ ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT EQ LPAREN ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {ELSE WHILE ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT EQ ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT EQ LPAREN ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {ELSE WHILE OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT EQ ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {ELSE WHILE AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT EQ LPAREN ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {ELSE WHILE OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {ELSE WHILE AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {ELSE WHILE XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {ELSE WHILE XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression_opt ::= (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {ELSE WHILE OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {ELSE WHILE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT EQ ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [return_statement ::= RETURN (*) expression_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression_opt ::= (*) expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {ELSE WHILE OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on expression_opt to state [414]
transition on and_expression to state [198]
transition on class_instance_creation_expression to state [196]
transition on conditional_or_expression to state [197]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on expression to state [375]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [144]: {
  [try_statement ::= TRY (*) block terminators_opt catches terminators_opt finally , {ELSE WHILE NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {CATCH FINALLY NEWLINE ENDOFFILE }]
  [try_statement ::= TRY (*) block terminators_opt catches , {ELSE WHILE NEWLINE ENDOFFILE }]
  [try_statement ::= TRY (*) block terminators_opt finally , {ELSE WHILE NEWLINE ENDOFFILE }]
}
transition on block to state [399]
transition on lbrace_multiline to state [104]
transition on LBRACE to state [47]

-------------------
lalr_state [145]: {
  [statement_without_trailing_substatement ::= expression_statement (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [146]: {
  [identifier_opt ::= (*) IDENTIFIER , {ELSE WHILE NEWLINE ENDOFFILE }]
  [identifier_opt ::= (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
  [break_statement ::= BREAK (*) identifier_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [390]
transition on identifier_opt to state [398]

-------------------
lalr_state [147]: {
  [method_invocation ::= name (*) lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN RPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= name (*) DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [class_or_interface_type ::= name (*) , {IDENTIFIER }]
  [field_access ::= name (*) DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [dims ::= (*) dims lbrack_multiline rbrack_multiline , {LBRACK IDENTIFIER }]
  [qualified_name ::= name (*) DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [postfix_expression ::= name (*) , {PLUSPLUS MINUSMINUS }]
  [array_access ::= name (*) lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [dims ::= (*) lbrack_multiline rbrack_multiline , {LBRACK IDENTIFIER }]
  [lbrack_multiline ::= (*) LBRACK terminators_opt , {RBRACK LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [left_hand_side ::= name (*) , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_type ::= name (*) dims , {IDENTIFIER }]
  [method_invocation ::= name (*) DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
}
transition on DOT to state [242]
transition on dims to state [78]
transition on LPAREN to state [89]
transition on lparen_multiline to state [241]
transition on LBRACK to state [77]
transition on lbrack_multiline to state [397]

-------------------
lalr_state [148]: {
  [literal ::= NULL_LITERAL (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [149]: {
  [literal ::= STRING_LITERAL (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [150]: {
  [primary_no_new_array ::= THIS (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [151]: {
  [terminator ::= (*) NEWLINE , {RBRACE NEWLINE ENDOFFILE }]
  [block ::= lbrace_multiline block_statements_opt (*) rbrace_multiline , {ELSE WHILE CATCH FINALLY NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RBRACE }]
  [terminators ::= (*) terminator terminators , {RBRACE }]
  [terminators_opt ::= (*) , {RBRACE }]
  [terminator ::= (*) ENDOFFILE , {RBRACE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RBRACE }]
  [rbrace_multiline ::= (*) terminators_opt RBRACE , {ELSE WHILE CATCH FINALLY NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on rbrace_multiline to state [396]
transition on terminators_opt to state [312]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [152]: {
  [statement_expression ::= assignment (*) , {SEMICOLON COMMA ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [153]: {
  [statement ::= while_statement (*) , {WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [154]: {
  [field_access ::= primary (*) DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= primary (*) DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= primary (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on DOT to state [391]

-------------------
lalr_state [155]: {
  [statement_without_trailing_substatement ::= continue_statement (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [156]: {
  [statement_expression ::= predecrement_expression (*) , {SEMICOLON COMMA ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [157]: {
  [statement ::= labeled_statement (*) , {WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [158]: {
  [statement ::= if_then_else_statement (*) , {WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [159]: {
  [identifier_opt ::= (*) IDENTIFIER , {ELSE WHILE NEWLINE ENDOFFILE }]
  [continue_statement ::= CONTINUE (*) identifier_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [identifier_opt ::= (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [390]
transition on identifier_opt to state [389]

-------------------
lalr_state [160]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [if_then_statement ::= IF (*) expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= IF (*) expression terminators statement_no_short_if ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on expression to state [341]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [161]: {
  [statement_without_trailing_substatement ::= throw_statement (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [162]: {
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= MINUSMINUS (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on name to state [213]
transition on NULL_LITERAL to state [148]
transition on SUPER to state [134]
transition on array_access to state [215]
transition on NEW to state [167]
transition on literal to state [169]
transition on array_creation_expression to state [137]
transition on PLUSPLUS to state [165]
transition on qualified_name to state [35]
transition on primary to state [154]
transition on MINUS to state [179]
transition on primary_no_new_array to state [164]
transition on NUMBER_LITERAL to state [127]
transition on postdecrement_expression to state [190]
transition on STRING_LITERAL to state [149]
transition on postfix_expression to state [193]
transition on THIS to state [150]
transition on unary_expression_not_plus_minus to state [194]
transition on LPAREN to state [89]
transition on unary_expression to state [340]
transition on preincrement_expression to state [202]
transition on MINUSMINUS to state [162]
transition on IDENTIFIER to state [34]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on method_invocation to state [201]
transition on lparen_multiline to state [166]
transition on COMP to state [185]
transition on predecrement_expression to state [178]
transition on UNDEFINED_LITERAL to state [128]
transition on class_instance_creation_expression to state [196]
transition on PLUS to state [186]
transition on postincrement_expression to state [177]
transition on field_access to state [212]

-------------------
lalr_state [163]: {
  [statement_expression ::= postincrement_expression (*) , {SEMICOLON COMMA ELSE WHILE NEWLINE ENDOFFILE }]
  [postfix_expression ::= postincrement_expression (*) , {PLUSPLUS MINUSMINUS }]
}

-------------------
lalr_state [164]: {
  [array_access ::= primary_no_new_array (*) lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [lbrack_multiline ::= (*) LBRACK terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [primary ::= primary_no_new_array (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on LBRACK to state [77]
transition on lbrack_multiline to state [337]

-------------------
lalr_state [165]: {
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= PLUSPLUS (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on name to state [213]
transition on NULL_LITERAL to state [148]
transition on SUPER to state [134]
transition on array_access to state [215]
transition on NEW to state [167]
transition on literal to state [169]
transition on array_creation_expression to state [137]
transition on PLUSPLUS to state [165]
transition on qualified_name to state [35]
transition on primary to state [154]
transition on MINUS to state [179]
transition on primary_no_new_array to state [164]
transition on NUMBER_LITERAL to state [127]
transition on postdecrement_expression to state [190]
transition on STRING_LITERAL to state [149]
transition on postfix_expression to state [193]
transition on THIS to state [150]
transition on unary_expression_not_plus_minus to state [194]
transition on LPAREN to state [89]
transition on unary_expression to state [336]
transition on preincrement_expression to state [202]
transition on MINUSMINUS to state [162]
transition on IDENTIFIER to state [34]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on method_invocation to state [201]
transition on lparen_multiline to state [166]
transition on COMP to state [185]
transition on predecrement_expression to state [178]
transition on class_instance_creation_expression to state [196]
transition on UNDEFINED_LITERAL to state [128]
transition on PLUS to state [186]
transition on postincrement_expression to state [177]
transition on field_access to state [212]

-------------------
lalr_state [166]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {RPAREN NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {RPAREN ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {RPAREN ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {RPAREN OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {RPAREN AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {RPAREN OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= lparen_multiline (*) expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {RPAREN AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {RPAREN NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {RPAREN XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {RPAREN NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {RPAREN XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {RPAREN OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {RPAREN OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on expression to state [334]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [167]: {
  [class_type ::= (*) class_or_interface_type , {LPAREN }]
  [primitive_type ::= (*) STRING , {LBRACK }]
  [array_creation_expression ::= NEW (*) primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT LPAREN }]
  [class_or_interface_type ::= (*) name , {LBRACK LPAREN }]
  [primitive_type ::= (*) OBJECT , {LBRACK }]
  [primitive_type ::= (*) NUMBER , {LBRACK }]
  [array_creation_expression ::= NEW (*) class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT LPAREN }]
  [class_instance_creation_expression ::= NEW (*) class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primitive_type ::= (*) BOOLEAN , {LBRACK }]
  [array_creation_expression ::= NEW (*) class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= NEW (*) primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT LPAREN }]
  [class_instance_creation_expression ::= NEW (*) class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on class_type to state [173]
transition on IDENTIFIER to state [34]
transition on primitive_type to state [172]
transition on qualified_name to state [35]
transition on STRING to state [67]
transition on class_or_interface_type to state [171]
transition on BOOLEAN to state [66]
transition on OBJECT to state [65]
transition on NUMBER to state [69]
transition on name to state [31]

-------------------
lalr_state [168]: {
  [block_statement ::= statement (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [169]: {
  [primary_no_new_array ::= literal (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [170]: {
  [statement_without_trailing_substatement ::= do_statement (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [171]: {
  [class_type ::= class_or_interface_type (*) , {LPAREN }]
  [dim_exprs ::= (*) dim_exprs dim_expr , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dims ::= (*) dims lbrack_multiline rbrack_multiline , {LBRACK LBRACE }]
  [array_creation_expression ::= NEW class_or_interface_type (*) dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dim_exprs ::= (*) dim_expr , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dims ::= (*) lbrack_multiline rbrack_multiline , {LBRACK LBRACE }]
  [array_creation_expression ::= NEW class_or_interface_type (*) dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lbrack_multiline ::= (*) LBRACK terminators_opt , {RBRACK LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [dim_expr ::= (*) lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on dims to state [331]
transition on dim_exprs to state [330]
transition on LBRACK to state [77]
transition on dim_expr to state [304]
transition on lbrack_multiline to state [305]

-------------------
lalr_state [172]: {
  [dim_expr ::= (*) lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= NEW primitive_type (*) dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= NEW primitive_type (*) dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dim_exprs ::= (*) dim_exprs dim_expr , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lbrack_multiline ::= (*) LBRACK terminators_opt , {RBRACK LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [dims ::= (*) dims lbrack_multiline rbrack_multiline , {LBRACK LBRACE }]
  [dim_exprs ::= (*) dim_expr , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dims ::= (*) lbrack_multiline rbrack_multiline , {LBRACK LBRACE }]
}
transition on dims to state [307]
transition on dim_exprs to state [306]
transition on LBRACK to state [77]
transition on lbrack_multiline to state [305]
transition on dim_expr to state [304]

-------------------
lalr_state [173]: {
  [class_instance_creation_expression ::= NEW class_type (*) lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN RPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= NEW class_type (*) lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on LPAREN to state [89]
transition on lparen_multiline to state [174]

-------------------
lalr_state [174]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [class_instance_creation_expression ::= NEW class_type lparen_multiline (*) argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {COMMA RPAREN ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [class_instance_creation_expression ::= NEW class_type lparen_multiline (*) argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {COMMA RPAREN OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list_opt ::= (*) , {RPAREN NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {COMMA RPAREN OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list_opt ::= (*) argument_list , {RPAREN NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {COMMA RPAREN AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list ::= (*) expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list ::= (*) argument_list comma_multiline expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {COMMA RPAREN XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {COMMA RPAREN OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on argument_list to state [192]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on expression to state [188]
transition on THIS to state [150]
transition on argument_list_opt to state [187]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [175]: {
  [additive_expression ::= additive_expression (*) PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= additive_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= additive_expression (*) MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on MINUS to state [222]
transition on PLUS to state [221]

-------------------
lalr_state [176]: {
  [conditional_or_expression ::= conditional_and_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= conditional_and_expression (*) ANDAND terminators_opt inclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on ANDAND to state [286]

-------------------
lalr_state [177]: {
  [postfix_expression ::= postincrement_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [178]: {
  [unary_expression ::= predecrement_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [179]: {
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= MINUS (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on name to state [213]
transition on NULL_LITERAL to state [148]
transition on SUPER to state [134]
transition on array_access to state [215]
transition on NEW to state [167]
transition on literal to state [169]
transition on array_creation_expression to state [137]
transition on PLUSPLUS to state [165]
transition on qualified_name to state [35]
transition on primary to state [154]
transition on MINUS to state [179]
transition on primary_no_new_array to state [164]
transition on NUMBER_LITERAL to state [127]
transition on postdecrement_expression to state [190]
transition on STRING_LITERAL to state [149]
transition on postfix_expression to state [193]
transition on THIS to state [150]
transition on unary_expression_not_plus_minus to state [194]
transition on LPAREN to state [89]
transition on unary_expression to state [303]
transition on preincrement_expression to state [202]
transition on MINUSMINUS to state [162]
transition on IDENTIFIER to state [34]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on method_invocation to state [201]
transition on lparen_multiline to state [166]
transition on COMP to state [185]
transition on predecrement_expression to state [178]
transition on UNDEFINED_LITERAL to state [128]
transition on class_instance_creation_expression to state [196]
transition on PLUS to state [186]
transition on postincrement_expression to state [177]
transition on field_access to state [212]

-------------------
lalr_state [180]: {
  [method_invocation ::= name (*) lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN RPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= name (*) DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= name (*) DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= name (*) DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= name (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= name (*) lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [lbrack_multiline ::= (*) LBRACK terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [left_hand_side ::= name (*) , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [method_invocation ::= name (*) DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on DOT to state [242]
transition on LPAREN to state [89]
transition on lparen_multiline to state [241]
transition on LBRACK to state [77]
transition on lbrack_multiline to state [240]

-------------------
lalr_state [181]: {
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= NOT (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on name to state [213]
transition on NULL_LITERAL to state [148]
transition on SUPER to state [134]
transition on array_access to state [215]
transition on NEW to state [167]
transition on literal to state [169]
transition on array_creation_expression to state [137]
transition on PLUSPLUS to state [165]
transition on qualified_name to state [35]
transition on primary to state [154]
transition on MINUS to state [179]
transition on primary_no_new_array to state [164]
transition on NUMBER_LITERAL to state [127]
transition on postdecrement_expression to state [190]
transition on STRING_LITERAL to state [149]
transition on postfix_expression to state [193]
transition on THIS to state [150]
transition on unary_expression_not_plus_minus to state [194]
transition on LPAREN to state [89]
transition on unary_expression to state [302]
transition on preincrement_expression to state [202]
transition on MINUSMINUS to state [162]
transition on IDENTIFIER to state [34]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on method_invocation to state [201]
transition on lparen_multiline to state [166]
transition on COMP to state [185]
transition on predecrement_expression to state [178]
transition on class_instance_creation_expression to state [196]
transition on UNDEFINED_LITERAL to state [128]
transition on PLUS to state [186]
transition on postincrement_expression to state [177]
transition on field_access to state [212]

-------------------
lalr_state [182]: {
  [equality_expression ::= equality_expression (*) EQEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= equality_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= equality_expression (*) NOTEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on EQEQ to state [275]
transition on NOTEQ to state [274]

-------------------
lalr_state [183]: {
  [exclusive_or_expression ::= exclusive_or_expression (*) XOR terminators_opt and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= exclusive_or_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on XOR to state [268]

-------------------
lalr_state [184]: {
  [assignment_expression ::= assignment (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [185]: {
  [unary_expression_not_plus_minus ::= COMP (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on name to state [213]
transition on NULL_LITERAL to state [148]
transition on SUPER to state [134]
transition on array_access to state [215]
transition on NEW to state [167]
transition on literal to state [169]
transition on array_creation_expression to state [137]
transition on PLUSPLUS to state [165]
transition on qualified_name to state [35]
transition on primary to state [154]
transition on MINUS to state [179]
transition on primary_no_new_array to state [164]
transition on NUMBER_LITERAL to state [127]
transition on postdecrement_expression to state [190]
transition on STRING_LITERAL to state [149]
transition on postfix_expression to state [193]
transition on THIS to state [150]
transition on unary_expression_not_plus_minus to state [194]
transition on LPAREN to state [89]
transition on unary_expression to state [301]
transition on preincrement_expression to state [202]
transition on MINUSMINUS to state [162]
transition on IDENTIFIER to state [34]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on method_invocation to state [201]
transition on lparen_multiline to state [166]
transition on COMP to state [185]
transition on predecrement_expression to state [178]
transition on class_instance_creation_expression to state [196]
transition on UNDEFINED_LITERAL to state [128]
transition on PLUS to state [186]
transition on postincrement_expression to state [177]
transition on field_access to state [212]

-------------------
lalr_state [186]: {
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= PLUS (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on name to state [213]
transition on NULL_LITERAL to state [148]
transition on SUPER to state [134]
transition on array_access to state [215]
transition on NEW to state [167]
transition on literal to state [169]
transition on array_creation_expression to state [137]
transition on PLUSPLUS to state [165]
transition on qualified_name to state [35]
transition on primary to state [154]
transition on MINUS to state [179]
transition on primary_no_new_array to state [164]
transition on NUMBER_LITERAL to state [127]
transition on postdecrement_expression to state [190]
transition on STRING_LITERAL to state [149]
transition on postfix_expression to state [193]
transition on THIS to state [150]
transition on unary_expression_not_plus_minus to state [194]
transition on LPAREN to state [89]
transition on unary_expression to state [300]
transition on preincrement_expression to state [202]
transition on MINUSMINUS to state [162]
transition on IDENTIFIER to state [34]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on method_invocation to state [201]
transition on lparen_multiline to state [166]
transition on COMP to state [185]
transition on predecrement_expression to state [178]
transition on UNDEFINED_LITERAL to state [128]
transition on class_instance_creation_expression to state [196]
transition on PLUS to state [186]
transition on postincrement_expression to state [177]
transition on field_access to state [212]

-------------------
lalr_state [187]: {
  [terminator ::= (*) NEWLINE , {RPAREN NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RPAREN }]
  [class_instance_creation_expression ::= NEW class_type lparen_multiline argument_list_opt (*) rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RPAREN }]
  [terminators_opt ::= (*) , {RPAREN }]
  [rparen_multiline ::= (*) terminators_opt RPAREN , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= NEW class_type lparen_multiline argument_list_opt (*) rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {RPAREN NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RPAREN }]
}
transition on NEWLINE to state [43]
transition on rparen_multiline to state [298]
transition on terminators_opt to state [98]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [188]: {
  [argument_list ::= expression (*) , {COMMA RPAREN NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [189]: {
  [multiplicative_expression ::= unary_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [190]: {
  [postfix_expression ::= postdecrement_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [191]: {
  [assignment_expression ::= conditional_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [192]: {
  [comma_multiline ::= (*) COMMA terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [argument_list_opt ::= argument_list (*) , {RPAREN NEWLINE ENDOFFILE }]
  [argument_list ::= argument_list (*) comma_multiline expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
}
transition on comma_multiline to state [296]
transition on COMMA to state [36]

-------------------
lalr_state [193]: {
  [postdecrement_expression ::= postfix_expression (*) MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= postfix_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= postfix_expression (*) PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on PLUSPLUS to state [295]
transition on MINUSMINUS to state [294]

-------------------
lalr_state [194]: {
  [unary_expression ::= unary_expression_not_plus_minus (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [195]: {
  [relational_expression ::= shift_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= shift_expression (*) LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= shift_expression (*) URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= shift_expression (*) RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on RSHIFT to state [218]
transition on URSHIFT to state [217]
transition on LSHIFT to state [216]

-------------------
lalr_state [196]: {
  [primary_no_new_array ::= class_instance_creation_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [197]: {
  [question_multiline ::= (*) QUESTION terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [conditional_or_expression ::= conditional_or_expression (*) OROR terminators_opt conditional_and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_expression ::= conditional_or_expression (*) question_multiline expression colon_multiline conditional_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_expression ::= conditional_or_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on QUESTION to state [282]
transition on OROR to state [281]
transition on question_multiline to state [280]

-------------------
lalr_state [198]: {
  [and_expression ::= and_expression (*) AND terminators_opt equality_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= and_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on AND to state [271]

-------------------
lalr_state [199]: {
  [conditional_and_expression ::= inclusive_or_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= inclusive_or_expression (*) OR terminators_opt exclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on OR to state [265]

-------------------
lalr_state [200]: {
  [expression ::= assignment_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [201]: {
  [primary_no_new_array ::= method_invocation (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [202]: {
  [unary_expression ::= preincrement_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [203]: {
  [multiplicative_expression ::= multiplicative_expression (*) DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= multiplicative_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= multiplicative_expression (*) MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= multiplicative_expression (*) MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on DIV to state [227]
transition on MULT to state [226]
transition on MOD to state [225]

-------------------
lalr_state [204]: {
  [relational_expression ::= relational_expression (*) IS terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression (*) GT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= relational_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression (*) GTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression (*) LT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression (*) ISNT terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression (*) LTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on LTEQ to state [210]
transition on IS to state [209]
transition on ISNT to state [208]
transition on GT to state [207]
transition on GTEQ to state [206]
transition on LT to state [205]

-------------------
lalr_state [205]: {
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [relational_expression ::= relational_expression LT (*) terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [263]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [206]: {
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [relational_expression ::= relational_expression GTEQ (*) terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [261]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [207]: {
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [relational_expression ::= relational_expression GT (*) terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [259]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [208]: {
  [terminator ::= (*) NEWLINE , {ARRAY BOOLEAN NUMBER OBJECT STRING IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {ARRAY BOOLEAN NUMBER OBJECT STRING IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {ARRAY BOOLEAN NUMBER OBJECT STRING IDENTIFIER }]
  [terminators_opt ::= (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {ARRAY BOOLEAN NUMBER OBJECT STRING IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression ISNT (*) terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {ARRAY BOOLEAN NUMBER OBJECT STRING IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [257]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [209]: {
  [terminator ::= (*) NEWLINE , {ARRAY BOOLEAN NUMBER OBJECT STRING IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression IS (*) terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {ARRAY BOOLEAN NUMBER OBJECT STRING IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {ARRAY BOOLEAN NUMBER OBJECT STRING IDENTIFIER }]
  [terminators_opt ::= (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {ARRAY BOOLEAN NUMBER OBJECT STRING IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {ARRAY BOOLEAN NUMBER OBJECT STRING IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [254]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [210]: {
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [relational_expression ::= relational_expression LTEQ (*) terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [211]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [211]: {
  [shift_expression ::= (*) additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression LTEQ terminators_opt (*) shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [215]
transition on preincrement_expression to state [202]
transition on multiplicative_expression to state [203]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on primary_no_new_array to state [164]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [214]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on unary_expression to state [189]
transition on postdecrement_expression to state [190]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on lparen_multiline to state [166]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on name to state [213]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on predecrement_expression to state [178]
transition on literal to state [169]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on additive_expression to state [175]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [212]

-------------------
lalr_state [212]: {
  [primary_no_new_array ::= field_access (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [213]: {
  [method_invocation ::= name (*) lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN RPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= name (*) DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= name (*) DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= name (*) DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= name (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= name (*) lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lbrack_multiline ::= (*) LBRACK terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [method_invocation ::= name (*) DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on DOT to state [242]
transition on LPAREN to state [89]
transition on lparen_multiline to state [241]
transition on LBRACK to state [77]
transition on lbrack_multiline to state [240]

-------------------
lalr_state [214]: {
  [shift_expression ::= shift_expression (*) LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= shift_expression (*) URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression LTEQ terminators_opt shift_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= shift_expression (*) RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on RSHIFT to state [218]
transition on URSHIFT to state [217]
transition on LSHIFT to state [216]

-------------------
lalr_state [215]: {
  [primary_no_new_array ::= array_access (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [216]: {
  [shift_expression ::= shift_expression LSHIFT (*) terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [238]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [217]: {
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [shift_expression ::= shift_expression URSHIFT (*) terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [236]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [218]: {
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [shift_expression ::= shift_expression RSHIFT (*) terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [219]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [219]: {
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= shift_expression RSHIFT terminators_opt (*) additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [215]
transition on preincrement_expression to state [202]
transition on multiplicative_expression to state [203]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on primary_no_new_array to state [164]
transition on class_instance_creation_expression to state [196]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on unary_expression to state [189]
transition on postdecrement_expression to state [190]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on lparen_multiline to state [166]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on name to state [213]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on predecrement_expression to state [178]
transition on literal to state [169]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on additive_expression to state [220]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [212]

-------------------
lalr_state [220]: {
  [additive_expression ::= additive_expression (*) PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= shift_expression RSHIFT terminators_opt additive_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= additive_expression (*) MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on MINUS to state [222]
transition on PLUS to state [221]

-------------------
lalr_state [221]: {
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= additive_expression PLUS (*) terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [234]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [222]: {
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= additive_expression MINUS (*) terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [223]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [223]: {
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= additive_expression MINUS terminators_opt (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on name to state [213]
transition on NULL_LITERAL to state [148]
transition on SUPER to state [134]
transition on array_access to state [215]
transition on NEW to state [167]
transition on multiplicative_expression to state [224]
transition on literal to state [169]
transition on array_creation_expression to state [137]
transition on PLUSPLUS to state [165]
transition on qualified_name to state [35]
transition on primary to state [154]
transition on MINUS to state [179]
transition on primary_no_new_array to state [164]
transition on NUMBER_LITERAL to state [127]
transition on postdecrement_expression to state [190]
transition on STRING_LITERAL to state [149]
transition on postfix_expression to state [193]
transition on THIS to state [150]
transition on unary_expression_not_plus_minus to state [194]
transition on LPAREN to state [89]
transition on unary_expression to state [189]
transition on preincrement_expression to state [202]
transition on MINUSMINUS to state [162]
transition on IDENTIFIER to state [34]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on method_invocation to state [201]
transition on lparen_multiline to state [166]
transition on COMP to state [185]
transition on predecrement_expression to state [178]
transition on class_instance_creation_expression to state [196]
transition on UNDEFINED_LITERAL to state [128]
transition on PLUS to state [186]
transition on postincrement_expression to state [177]
transition on field_access to state [212]

-------------------
lalr_state [224]: {
  [multiplicative_expression ::= multiplicative_expression (*) DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= additive_expression MINUS terminators_opt multiplicative_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= multiplicative_expression (*) MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= multiplicative_expression (*) MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on DIV to state [227]
transition on MULT to state [226]
transition on MOD to state [225]

-------------------
lalr_state [225]: {
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [multiplicative_expression ::= multiplicative_expression MOD (*) terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [232]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [226]: {
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [multiplicative_expression ::= multiplicative_expression MULT (*) terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [230]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [227]: {
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [multiplicative_expression ::= multiplicative_expression DIV (*) terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [228]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [228]: {
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= multiplicative_expression DIV terminators_opt (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on name to state [213]
transition on NULL_LITERAL to state [148]
transition on SUPER to state [134]
transition on array_access to state [215]
transition on NEW to state [167]
transition on literal to state [169]
transition on array_creation_expression to state [137]
transition on PLUSPLUS to state [165]
transition on qualified_name to state [35]
transition on primary to state [154]
transition on MINUS to state [179]
transition on primary_no_new_array to state [164]
transition on NUMBER_LITERAL to state [127]
transition on postdecrement_expression to state [190]
transition on STRING_LITERAL to state [149]
transition on postfix_expression to state [193]
transition on THIS to state [150]
transition on unary_expression_not_plus_minus to state [194]
transition on LPAREN to state [89]
transition on unary_expression to state [229]
transition on preincrement_expression to state [202]
transition on MINUSMINUS to state [162]
transition on IDENTIFIER to state [34]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on method_invocation to state [201]
transition on lparen_multiline to state [166]
transition on COMP to state [185]
transition on predecrement_expression to state [178]
transition on UNDEFINED_LITERAL to state [128]
transition on class_instance_creation_expression to state [196]
transition on PLUS to state [186]
transition on postincrement_expression to state [177]
transition on field_access to state [212]

-------------------
lalr_state [229]: {
  [multiplicative_expression ::= multiplicative_expression DIV terminators_opt unary_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [230]: {
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= multiplicative_expression MULT terminators_opt (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on name to state [213]
transition on NULL_LITERAL to state [148]
transition on SUPER to state [134]
transition on array_access to state [215]
transition on NEW to state [167]
transition on literal to state [169]
transition on array_creation_expression to state [137]
transition on PLUSPLUS to state [165]
transition on qualified_name to state [35]
transition on primary to state [154]
transition on MINUS to state [179]
transition on primary_no_new_array to state [164]
transition on NUMBER_LITERAL to state [127]
transition on postdecrement_expression to state [190]
transition on STRING_LITERAL to state [149]
transition on postfix_expression to state [193]
transition on THIS to state [150]
transition on unary_expression_not_plus_minus to state [194]
transition on LPAREN to state [89]
transition on unary_expression to state [231]
transition on preincrement_expression to state [202]
transition on MINUSMINUS to state [162]
transition on IDENTIFIER to state [34]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on method_invocation to state [201]
transition on lparen_multiline to state [166]
transition on COMP to state [185]
transition on predecrement_expression to state [178]
transition on UNDEFINED_LITERAL to state [128]
transition on class_instance_creation_expression to state [196]
transition on PLUS to state [186]
transition on postincrement_expression to state [177]
transition on field_access to state [212]

-------------------
lalr_state [231]: {
  [multiplicative_expression ::= multiplicative_expression MULT terminators_opt unary_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [232]: {
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [multiplicative_expression ::= multiplicative_expression MOD terminators_opt (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on name to state [213]
transition on NULL_LITERAL to state [148]
transition on SUPER to state [134]
transition on array_access to state [215]
transition on NEW to state [167]
transition on literal to state [169]
transition on array_creation_expression to state [137]
transition on PLUSPLUS to state [165]
transition on qualified_name to state [35]
transition on primary to state [154]
transition on MINUS to state [179]
transition on primary_no_new_array to state [164]
transition on NUMBER_LITERAL to state [127]
transition on postdecrement_expression to state [190]
transition on STRING_LITERAL to state [149]
transition on postfix_expression to state [193]
transition on THIS to state [150]
transition on unary_expression_not_plus_minus to state [194]
transition on LPAREN to state [89]
transition on unary_expression to state [233]
transition on preincrement_expression to state [202]
transition on MINUSMINUS to state [162]
transition on IDENTIFIER to state [34]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on method_invocation to state [201]
transition on lparen_multiline to state [166]
transition on COMP to state [185]
transition on predecrement_expression to state [178]
transition on class_instance_creation_expression to state [196]
transition on UNDEFINED_LITERAL to state [128]
transition on PLUS to state [186]
transition on postincrement_expression to state [177]
transition on field_access to state [212]

-------------------
lalr_state [233]: {
  [multiplicative_expression ::= multiplicative_expression MOD terminators_opt unary_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [234]: {
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= additive_expression PLUS terminators_opt (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on name to state [213]
transition on NULL_LITERAL to state [148]
transition on SUPER to state [134]
transition on array_access to state [215]
transition on NEW to state [167]
transition on multiplicative_expression to state [235]
transition on literal to state [169]
transition on array_creation_expression to state [137]
transition on PLUSPLUS to state [165]
transition on qualified_name to state [35]
transition on primary to state [154]
transition on MINUS to state [179]
transition on primary_no_new_array to state [164]
transition on NUMBER_LITERAL to state [127]
transition on postdecrement_expression to state [190]
transition on STRING_LITERAL to state [149]
transition on postfix_expression to state [193]
transition on THIS to state [150]
transition on unary_expression_not_plus_minus to state [194]
transition on LPAREN to state [89]
transition on unary_expression to state [189]
transition on preincrement_expression to state [202]
transition on MINUSMINUS to state [162]
transition on IDENTIFIER to state [34]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on method_invocation to state [201]
transition on lparen_multiline to state [166]
transition on COMP to state [185]
transition on predecrement_expression to state [178]
transition on class_instance_creation_expression to state [196]
transition on UNDEFINED_LITERAL to state [128]
transition on PLUS to state [186]
transition on postincrement_expression to state [177]
transition on field_access to state [212]

-------------------
lalr_state [235]: {
  [multiplicative_expression ::= multiplicative_expression (*) DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= multiplicative_expression (*) MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= additive_expression PLUS terminators_opt multiplicative_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= multiplicative_expression (*) MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on DIV to state [227]
transition on MULT to state [226]
transition on MOD to state [225]

-------------------
lalr_state [236]: {
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= shift_expression URSHIFT terminators_opt (*) additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [215]
transition on preincrement_expression to state [202]
transition on multiplicative_expression to state [203]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on primary_no_new_array to state [164]
transition on class_instance_creation_expression to state [196]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on unary_expression to state [189]
transition on postdecrement_expression to state [190]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on lparen_multiline to state [166]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on name to state [213]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on predecrement_expression to state [178]
transition on literal to state [169]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on additive_expression to state [237]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [212]

-------------------
lalr_state [237]: {
  [shift_expression ::= shift_expression URSHIFT terminators_opt additive_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= additive_expression (*) PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= additive_expression (*) MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on MINUS to state [222]
transition on PLUS to state [221]

-------------------
lalr_state [238]: {
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= shift_expression LSHIFT terminators_opt (*) additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [215]
transition on preincrement_expression to state [202]
transition on multiplicative_expression to state [203]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on primary_no_new_array to state [164]
transition on class_instance_creation_expression to state [196]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on unary_expression to state [189]
transition on postdecrement_expression to state [190]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on lparen_multiline to state [166]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on name to state [213]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on predecrement_expression to state [178]
transition on literal to state [169]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on additive_expression to state [239]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [212]

-------------------
lalr_state [239]: {
  [additive_expression ::= additive_expression (*) PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= additive_expression (*) MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= shift_expression LSHIFT terminators_opt additive_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on MINUS to state [222]
transition on PLUS to state [221]

-------------------
lalr_state [240]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {RBRACK NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {RBRACK LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {RBRACK EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {RBRACK NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {RBRACK ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {RBRACK LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {RBRACK EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK RBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {RBRACK ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {RBRACK EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK RBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {RBRACK OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {RBRACK AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK RBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {RBRACK OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {RBRACK PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {RBRACK AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {RBRACK NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {RBRACK PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {RBRACK XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {RBRACK NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {RBRACK PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {RBRACK XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {RBRACK NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {RBRACK LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {RBRACK OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {RBRACK NEWLINE ENDOFFILE }]
  [array_access ::= name lbrack_multiline (*) expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {RBRACK LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {RBRACK OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on class_instance_creation_expression to state [196]
transition on conditional_or_expression to state [197]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on expression to state [252]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [241]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {COMMA RPAREN ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {COMMA RPAREN OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list_opt ::= (*) , {RPAREN NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [method_invocation ::= name lparen_multiline (*) argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {COMMA RPAREN OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list_opt ::= (*) argument_list , {RPAREN NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {COMMA RPAREN AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list ::= (*) expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list ::= (*) argument_list comma_multiline expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {COMMA RPAREN XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {COMMA RPAREN OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on argument_list to state [192]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on expression to state [188]
transition on argument_list_opt to state [250]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [242]: {
  [field_access ::= name DOT (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= name DOT (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= name DOT (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= name DOT (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on THIS to state [244]
transition on IDENTIFIER to state [46]
transition on SUPER to state [243]

-------------------
lalr_state [243]: {
  [field_access ::= name DOT SUPER (*) DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= name DOT SUPER (*) DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on DOT to state [245]

-------------------
lalr_state [244]: {
  [primary_no_new_array ::= name DOT THIS (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [245]: {
  [field_access ::= name DOT SUPER DOT (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= name DOT SUPER DOT (*) IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [246]

-------------------
lalr_state [246]: {
  [field_access ::= name DOT SUPER DOT IDENTIFIER (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= name DOT SUPER DOT IDENTIFIER (*) lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN RPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on LPAREN to state [89]
transition on lparen_multiline to state [247]

-------------------
lalr_state [247]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {COMMA RPAREN ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {COMMA RPAREN OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list_opt ::= (*) , {RPAREN NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {COMMA RPAREN OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list_opt ::= (*) argument_list , {RPAREN NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {COMMA RPAREN AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list ::= (*) expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list ::= (*) argument_list comma_multiline expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {COMMA RPAREN XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= name DOT SUPER DOT IDENTIFIER lparen_multiline (*) argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {COMMA RPAREN OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on argument_list to state [192]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on expression to state [188]
transition on THIS to state [150]
transition on argument_list_opt to state [248]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [248]: {
  [terminator ::= (*) NEWLINE , {RPAREN NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RPAREN }]
  [method_invocation ::= name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt (*) rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RPAREN }]
  [rparen_multiline ::= (*) terminators_opt RPAREN , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {RPAREN }]
  [terminator ::= (*) ENDOFFILE , {RPAREN NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RPAREN }]
}
transition on NEWLINE to state [43]
transition on rparen_multiline to state [249]
transition on terminators_opt to state [98]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [249]: {
  [method_invocation ::= name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [250]: {
  [terminator ::= (*) NEWLINE , {RPAREN NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RPAREN }]
  [terminators ::= (*) terminator terminators , {RPAREN }]
  [rparen_multiline ::= (*) terminators_opt RPAREN , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {RPAREN }]
  [terminator ::= (*) ENDOFFILE , {RPAREN NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RPAREN }]
  [method_invocation ::= name lparen_multiline argument_list_opt (*) rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [98]
transition on rparen_multiline to state [251]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [251]: {
  [method_invocation ::= name lparen_multiline argument_list_opt rparen_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [252]: {
  [terminator ::= (*) NEWLINE , {RBRACK NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RBRACK }]
  [rbrack_multiline ::= (*) terminators_opt RBRACK , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= name lbrack_multiline expression (*) rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RBRACK }]
  [terminators_opt ::= (*) , {RBRACK }]
  [terminator ::= (*) ENDOFFILE , {RBRACK NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RBRACK }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [81]
transition on rbrack_multiline to state [253]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [253]: {
  [array_access ::= name lbrack_multiline expression rbrack_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [254]: {
  [array_type ::= (*) name dims , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [reference_type ::= (*) class_or_interface_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primitive_type ::= (*) STRING , {LBRACK }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_type ::= (*) primitive_type dims , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_or_interface_type ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primitive_type ::= (*) OBJECT , {LBRACK }]
  [primitive_type ::= (*) NUMBER , {LBRACK }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_type ::= (*) ARRAY , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression IS terminators_opt (*) reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [reference_type ::= (*) array_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primitive_type ::= (*) BOOLEAN , {LBRACK }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on array_type to state [72]
transition on IDENTIFIER to state [34]
transition on reference_type to state [256]
transition on primitive_type to state [255]
transition on qualified_name to state [35]
transition on STRING to state [67]
transition on class_or_interface_type to state [62]
transition on BOOLEAN to state [66]
transition on OBJECT to state [65]
transition on NUMBER to state [69]
transition on ARRAY to state [73]
transition on name to state [75]

-------------------
lalr_state [255]: {
  [lbrack_multiline ::= (*) LBRACK terminators_opt , {RBRACK NEWLINE ENDOFFILE }]
  [dims ::= (*) dims lbrack_multiline rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_type ::= primitive_type (*) dims , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dims ::= (*) lbrack_multiline rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on dims to state [85]
transition on LBRACK to state [77]
transition on lbrack_multiline to state [76]

-------------------
lalr_state [256]: {
  [relational_expression ::= relational_expression IS terminators_opt reference_type (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [257]: {
  [array_type ::= (*) name dims , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [reference_type ::= (*) class_or_interface_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primitive_type ::= (*) STRING , {LBRACK }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression ISNT terminators_opt (*) reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_type ::= (*) primitive_type dims , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_or_interface_type ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primitive_type ::= (*) OBJECT , {LBRACK }]
  [primitive_type ::= (*) NUMBER , {LBRACK }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_type ::= (*) ARRAY , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [reference_type ::= (*) array_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primitive_type ::= (*) BOOLEAN , {LBRACK }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on array_type to state [72]
transition on IDENTIFIER to state [34]
transition on reference_type to state [258]
transition on primitive_type to state [255]
transition on qualified_name to state [35]
transition on STRING to state [67]
transition on class_or_interface_type to state [62]
transition on BOOLEAN to state [66]
transition on OBJECT to state [65]
transition on NUMBER to state [69]
transition on ARRAY to state [73]
transition on name to state [75]

-------------------
lalr_state [258]: {
  [relational_expression ::= relational_expression ISNT terminators_opt reference_type (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [259]: {
  [shift_expression ::= (*) additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression GT terminators_opt (*) shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [215]
transition on preincrement_expression to state [202]
transition on multiplicative_expression to state [203]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on primary_no_new_array to state [164]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [260]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on unary_expression to state [189]
transition on postdecrement_expression to state [190]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on lparen_multiline to state [166]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on name to state [213]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on predecrement_expression to state [178]
transition on literal to state [169]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on additive_expression to state [175]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [212]

-------------------
lalr_state [260]: {
  [relational_expression ::= relational_expression GT terminators_opt shift_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= shift_expression (*) LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= shift_expression (*) URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= shift_expression (*) RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on RSHIFT to state [218]
transition on URSHIFT to state [217]
transition on LSHIFT to state [216]

-------------------
lalr_state [261]: {
  [shift_expression ::= (*) additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression GTEQ terminators_opt (*) shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [215]
transition on preincrement_expression to state [202]
transition on multiplicative_expression to state [203]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on primary_no_new_array to state [164]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [262]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on unary_expression to state [189]
transition on postdecrement_expression to state [190]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on lparen_multiline to state [166]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on name to state [213]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on predecrement_expression to state [178]
transition on literal to state [169]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on additive_expression to state [175]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [212]

-------------------
lalr_state [262]: {
  [shift_expression ::= shift_expression (*) LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression GTEQ terminators_opt shift_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= shift_expression (*) URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= shift_expression (*) RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on RSHIFT to state [218]
transition on URSHIFT to state [217]
transition on LSHIFT to state [216]

-------------------
lalr_state [263]: {
  [shift_expression ::= (*) additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression LT terminators_opt (*) shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [215]
transition on preincrement_expression to state [202]
transition on multiplicative_expression to state [203]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on primary_no_new_array to state [164]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [264]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on unary_expression to state [189]
transition on postdecrement_expression to state [190]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on lparen_multiline to state [166]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on name to state [213]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on predecrement_expression to state [178]
transition on literal to state [169]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on additive_expression to state [175]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [212]

-------------------
lalr_state [264]: {
  [shift_expression ::= shift_expression (*) LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= shift_expression (*) URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression LT terminators_opt shift_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= shift_expression (*) RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on RSHIFT to state [218]
transition on URSHIFT to state [217]
transition on LSHIFT to state [216]

-------------------
lalr_state [265]: {
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [inclusive_or_expression ::= inclusive_or_expression OR (*) terminators_opt exclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [266]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [266]: {
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= inclusive_or_expression OR terminators_opt (*) exclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [215]
transition on relational_expression to state [204]
transition on preincrement_expression to state [202]
transition on multiplicative_expression to state [203]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [267]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [213]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on additive_expression to state [175]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [212]

-------------------
lalr_state [267]: {
  [inclusive_or_expression ::= inclusive_or_expression OR terminators_opt exclusive_or_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= exclusive_or_expression (*) XOR terminators_opt and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on XOR to state [268]

-------------------
lalr_state [268]: {
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= exclusive_or_expression XOR (*) terminators_opt and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [269]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [269]: {
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= exclusive_or_expression XOR terminators_opt (*) and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [215]
transition on relational_expression to state [204]
transition on preincrement_expression to state [202]
transition on multiplicative_expression to state [203]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on primary_no_new_array to state [164]
transition on and_expression to state [270]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on lparen_multiline to state [166]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [213]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on additive_expression to state [175]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [212]

-------------------
lalr_state [270]: {
  [exclusive_or_expression ::= exclusive_or_expression XOR terminators_opt and_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= and_expression (*) AND terminators_opt equality_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on AND to state [271]

-------------------
lalr_state [271]: {
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [and_expression ::= and_expression AND (*) terminators_opt equality_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [272]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [272]: {
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= and_expression AND terminators_opt (*) equality_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [215]
transition on relational_expression to state [204]
transition on preincrement_expression to state [202]
transition on multiplicative_expression to state [203]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on primary_no_new_array to state [164]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on lparen_multiline to state [166]
transition on equality_expression to state [273]
transition on NOT to state [181]
transition on name to state [213]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on additive_expression to state [175]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [212]

-------------------
lalr_state [273]: {
  [equality_expression ::= equality_expression (*) EQEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= and_expression AND terminators_opt equality_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= equality_expression (*) NOTEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on EQEQ to state [275]
transition on NOTEQ to state [274]

-------------------
lalr_state [274]: {
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [equality_expression ::= equality_expression NOTEQ (*) terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [278]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [275]: {
  [equality_expression ::= equality_expression EQEQ (*) terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [276]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [276]: {
  [shift_expression ::= (*) additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= equality_expression EQEQ terminators_opt (*) relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [215]
transition on relational_expression to state [277]
transition on preincrement_expression to state [202]
transition on multiplicative_expression to state [203]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on primary_no_new_array to state [164]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on unary_expression to state [189]
transition on postdecrement_expression to state [190]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on lparen_multiline to state [166]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on name to state [213]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on predecrement_expression to state [178]
transition on literal to state [169]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on additive_expression to state [175]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [212]

-------------------
lalr_state [277]: {
  [relational_expression ::= relational_expression (*) IS terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression (*) GT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression (*) GTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression (*) LT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= equality_expression EQEQ terminators_opt relational_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression (*) ISNT terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression (*) LTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on LTEQ to state [210]
transition on IS to state [209]
transition on ISNT to state [208]
transition on GT to state [207]
transition on GTEQ to state [206]
transition on LT to state [205]

-------------------
lalr_state [278]: {
  [shift_expression ::= (*) additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= equality_expression NOTEQ terminators_opt (*) relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [215]
transition on relational_expression to state [279]
transition on preincrement_expression to state [202]
transition on multiplicative_expression to state [203]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on primary_no_new_array to state [164]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on unary_expression to state [189]
transition on postdecrement_expression to state [190]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on lparen_multiline to state [166]
transition on NOT to state [181]
transition on BOOLEAN_LITERAL to state [129]
transition on name to state [213]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on predecrement_expression to state [178]
transition on literal to state [169]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on additive_expression to state [175]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [212]

-------------------
lalr_state [279]: {
  [relational_expression ::= relational_expression (*) IS terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression (*) GT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= equality_expression NOTEQ terminators_opt relational_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression (*) GTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression (*) LT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression (*) ISNT terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= relational_expression (*) LTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on LTEQ to state [210]
transition on IS to state [209]
transition on ISNT to state [208]
transition on GT to state [207]
transition on GTEQ to state [206]
transition on LT to state [205]

-------------------
lalr_state [280]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {COLON }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {COLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT EQ COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [equality_expression ::= (*) relational_expression , {COLON EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [expression ::= (*) assignment_expression , {COLON }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {COLON ANDAND OROR QUESTION }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT EQ COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary ::= (*) array_creation_expression , {DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {COLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) primary , {MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {COLON EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT EQ LPAREN COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {COLON ANDAND OROR QUESTION }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT EQ COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) name , {MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {COLON EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT EQ LPAREN COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [conditional_or_expression ::= (*) conditional_and_expression , {COLON OROR QUESTION }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT EQ COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) postincrement_expression , {MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [and_expression ::= (*) equality_expression , {COLON AND XOR OR ANDAND OROR QUESTION }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT EQ LPAREN COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {COLON OROR QUESTION }]
  [additive_expression ::= (*) multiplicative_expression , {COLON PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {COLON AND XOR OR ANDAND OROR QUESTION }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [conditional_expression ::= (*) conditional_or_expression , {COLON }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {COLON PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {COLON XOR OR ANDAND OROR QUESTION }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [conditional_expression ::= conditional_or_expression question_multiline (*) expression colon_multiline conditional_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {COLON }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {COLON PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {COLON XOR OR ANDAND OROR QUESTION }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [assignment_expression ::= (*) conditional_expression , {COLON }]
  [shift_expression ::= (*) additive_expression , {COLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) preincrement_expression , {MULT COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COLON OR ANDAND OROR QUESTION }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [assignment_expression ::= (*) assignment , {COLON }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {COLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT EQ COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) predecrement_expression , {MULT COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {COLON OR ANDAND OROR QUESTION }]
  [multiplicative_expression ::= (*) unary_expression , {MULT COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary ::= (*) primary_no_new_array , {DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on class_instance_creation_expression to state [196]
transition on conditional_or_expression to state [197]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on expression to state [289]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [281]: {
  [conditional_or_expression ::= conditional_or_expression OROR (*) terminators_opt conditional_and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [284]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [282]: {
  [question_multiline ::= QUESTION (*) terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [283]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [283]: {
  [question_multiline ::= QUESTION terminators_opt (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}

-------------------
lalr_state [284]: {
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= conditional_or_expression OROR terminators_opt (*) conditional_and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [215]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [213]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [285]
transition on additive_expression to state [175]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [212]

-------------------
lalr_state [285]: {
  [conditional_or_expression ::= conditional_or_expression OROR terminators_opt conditional_and_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= conditional_and_expression (*) ANDAND terminators_opt inclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on ANDAND to state [286]

-------------------
lalr_state [286]: {
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= conditional_and_expression ANDAND (*) terminators_opt inclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [287]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [287]: {
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= conditional_and_expression ANDAND terminators_opt (*) inclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [215]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on inclusive_or_expression to state [288]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [213]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on additive_expression to state [175]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [212]

-------------------
lalr_state [288]: {
  [inclusive_or_expression ::= inclusive_or_expression (*) OR terminators_opt exclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= conditional_and_expression ANDAND terminators_opt inclusive_or_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on OR to state [265]

-------------------
lalr_state [289]: {
  [conditional_expression ::= conditional_or_expression question_multiline expression (*) colon_multiline conditional_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
  [colon_multiline ::= (*) COLON terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on colon_multiline to state [291]
transition on COLON to state [290]

-------------------
lalr_state [290]: {
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [colon_multiline ::= COLON (*) terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [293]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [291]: {
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_expression ::= conditional_or_expression question_multiline expression colon_multiline (*) conditional_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [215]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on class_instance_creation_expression to state [196]
transition on conditional_or_expression to state [197]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [292]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [213]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [212]

-------------------
lalr_state [292]: {
  [conditional_expression ::= conditional_or_expression question_multiline expression colon_multiline conditional_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [293]: {
  [colon_multiline ::= COLON terminators_opt (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}

-------------------
lalr_state [294]: {
  [postdecrement_expression ::= postfix_expression MINUSMINUS (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [295]: {
  [postincrement_expression ::= postfix_expression PLUSPLUS (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [296]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {COMMA RPAREN ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {COMMA RPAREN OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {COMMA RPAREN OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {COMMA RPAREN AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list ::= argument_list comma_multiline (*) expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {COMMA RPAREN XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {COMMA RPAREN OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on class_instance_creation_expression to state [196]
transition on conditional_or_expression to state [197]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on expression to state [297]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [297]: {
  [argument_list ::= argument_list comma_multiline expression (*) , {COMMA RPAREN NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [298]: {
  [class_body ::= (*) lbrace_multiline class_body_declarations_opt rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= NEW class_type lparen_multiline argument_list_opt rparen_multiline (*) class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= NEW class_type lparen_multiline argument_list_opt rparen_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on lbrace_multiline to state [49]
transition on class_body to state [299]
transition on LBRACE to state [47]

-------------------
lalr_state [299]: {
  [class_instance_creation_expression ::= NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [300]: {
  [unary_expression ::= PLUS unary_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [301]: {
  [unary_expression_not_plus_minus ::= COMP unary_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [302]: {
  [unary_expression_not_plus_minus ::= NOT unary_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [303]: {
  [unary_expression ::= MINUS unary_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [304]: {
  [dim_exprs ::= dim_expr (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [305]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {RBRACK NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {RBRACK LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {RBRACK EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {RBRACK NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {RBRACK ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {RBRACK }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {RBRACK LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {RBRACK EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK RBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {RBRACK ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RBRACK }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {RBRACK EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK RBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {RBRACK OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RBRACK }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {RBRACK AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK RBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {RBRACK OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {RBRACK PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RBRACK }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [rbrack_multiline ::= (*) terminators_opt RBRACK , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {RBRACK AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [dim_expr ::= lbrack_multiline (*) expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {RBRACK NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {RBRACK PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminator ::= (*) NEWLINE , {RBRACK NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {RBRACK XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {RBRACK NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {RBRACK PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {RBRACK NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {RBRACK XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {RBRACK NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {RBRACK LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {RBRACK OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [dims ::= lbrack_multiline (*) rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {RBRACK NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {RBRACK LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {RBRACK OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on rbrack_multiline to state [84]
transition on postfix_expression to state [193]
transition on terminators to state [39]
transition on conditional_expression to state [191]
transition on NEWLINE to state [43]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on postdecrement_expression to state [190]
transition on MINUSMINUS to state [162]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on expression to state [328]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on terminator to state [40]
transition on terminators_opt to state [81]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on ENDOFFILE to state [41]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [306]: {
  [dim_expr ::= (*) lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dims_opt ::= (*) dims , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dim_exprs ::= dim_exprs (*) dim_expr , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dims ::= (*) dims lbrack_multiline rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lbrack_multiline ::= (*) LBRACK terminators_opt , {RBRACK LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [dims_opt ::= (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dims ::= (*) lbrack_multiline rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= NEW primitive_type dim_exprs (*) dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on dims to state [327]
transition on LBRACK to state [77]
transition on lbrack_multiline to state [305]
transition on dim_expr to state [326]
transition on dims_opt to state [325]

-------------------
lalr_state [307]: {
  [array_initializer ::= (*) lbrace_multiline variable_initializers rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= NEW primitive_type dims (*) array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {COMMA LBRACE RBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [array_initializer ::= (*) lbrace_multiline rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_initializer ::= (*) lbrace_multiline variable_initializers COMMA rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dims ::= dims (*) lbrack_multiline rbrack_multiline , {LBRACK LBRACE }]
  [lbrack_multiline ::= (*) LBRACK terminators_opt , {RBRACK NEWLINE ENDOFFILE }]
  [array_initializer ::= (*) lbrace_multiline comma_multiline rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on lbrace_multiline to state [309]
transition on LBRACK to state [77]
transition on lbrack_multiline to state [79]
transition on LBRACE to state [47]
transition on array_initializer to state [308]

-------------------
lalr_state [308]: {
  [array_creation_expression ::= NEW primitive_type dims array_initializer (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [309]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {COMMA RBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {COMMA RBRACE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {COMMA RBRACE ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {RBRACE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {COMMA RBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {COMMA LBRACE RBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {COMMA RBRACE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {COMMA RBRACE ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RBRACE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [rbrace_multiline ::= (*) terminators_opt RBRACE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {COMMA RBRACE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT COMMA RBRACE EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {COMMA RBRACE OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RBRACE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_initializer ::= lbrace_multiline (*) variable_initializers COMMA rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_initializer ::= (*) lbrace_multiline variable_initializers COMMA rbrace_multiline , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {COMMA RBRACE AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {COMMA RBRACE OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RBRACE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RBRACE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [variable_initializer ::= (*) expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_initializer ::= lbrace_multiline (*) variable_initializers rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_initializer ::= (*) lbrace_multiline variable_initializers rbrace_multiline , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {COMMA RBRACE AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {COMMA RBRACE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminator ::= (*) NEWLINE , {RBRACE NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [variable_initializer ::= (*) array_initializer , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [array_initializer ::= lbrace_multiline (*) comma_multiline rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_initializer ::= (*) lbrace_multiline comma_multiline rbrace_multiline , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RBRACE XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {COMMA RBRACE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {RBRACE NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_initializer ::= lbrace_multiline (*) rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_initializer ::= (*) lbrace_multiline rbrace_multiline , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {COMMA RBRACE XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {COMMA RBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [variable_initializers ::= (*) variable_initializer , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RBRACE OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {COMMA RBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [comma_multiline ::= (*) COMMA terminators_opt , {RBRACE NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [variable_initializers ::= (*) variable_initializers comma_multiline variable_initializer , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {COMMA RBRACE OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on comma_multiline to state [316]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on LBRACE to state [47]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on terminators to state [39]
transition on conditional_expression to state [191]
transition on NEWLINE to state [43]
transition on array_initializer to state [315]
transition on variable_initializer to state [314]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on postdecrement_expression to state [190]
transition on MINUSMINUS to state [162]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on expression to state [313]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on terminator to state [40]
transition on terminators_opt to state [312]
transition on COMMA to state [36]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on lbrace_multiline to state [309]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on variable_initializers to state [311]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on ENDOFFILE to state [41]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]
transition on rbrace_multiline to state [310]

-------------------
lalr_state [310]: {
  [array_initializer ::= lbrace_multiline rbrace_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [311]: {
  [array_initializer ::= lbrace_multiline variable_initializers (*) rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [rbrace_multiline ::= (*) terminators_opt RBRACE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [comma_multiline ::= (*) COMMA terminators_opt , {LBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) NEWLINE , {RBRACE NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RBRACE }]
  [array_initializer ::= lbrace_multiline variable_initializers (*) COMMA rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RBRACE }]
  [terminators_opt ::= (*) , {RBRACE }]
  [variable_initializers ::= variable_initializers (*) comma_multiline variable_initializer , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {RBRACE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RBRACE }]
}
transition on NEWLINE to state [43]
transition on rbrace_multiline to state [321]
transition on terminators_opt to state [312]
transition on comma_multiline to state [320]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]
transition on COMMA to state [319]

-------------------
lalr_state [312]: {
  [rbrace_multiline ::= terminators_opt (*) RBRACE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE CATCH FINALLY PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on RBRACE to state [318]

-------------------
lalr_state [313]: {
  [variable_initializer ::= expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [314]: {
  [variable_initializers ::= variable_initializer (*) , {COMMA RBRACE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [315]: {
  [variable_initializer ::= array_initializer (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [316]: {
  [terminator ::= (*) NEWLINE , {RBRACE NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RBRACE }]
  [terminators ::= (*) terminator terminators , {RBRACE }]
  [terminators_opt ::= (*) , {RBRACE }]
  [array_initializer ::= lbrace_multiline comma_multiline (*) rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {RBRACE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RBRACE }]
  [rbrace_multiline ::= (*) terminators_opt RBRACE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on rbrace_multiline to state [317]
transition on terminators_opt to state [312]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [317]: {
  [array_initializer ::= lbrace_multiline comma_multiline rbrace_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [318]: {
  [rbrace_multiline ::= terminators_opt RBRACE (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE CATCH FINALLY PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [319]: {
  [comma_multiline ::= COMMA (*) terminators_opt , {LBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [rbrace_multiline ::= (*) terminators_opt RBRACE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) NEWLINE , {RBRACE NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LBRACE RBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [array_initializer ::= lbrace_multiline variable_initializers COMMA (*) rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {LBRACE RBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LBRACE RBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {RBRACE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LBRACE RBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [324]
transition on rbrace_multiline to state [323]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [320]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {COMMA RBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {COMMA RBRACE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {COMMA RBRACE ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {COMMA RBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {COMMA LBRACE RBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {COMMA RBRACE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {COMMA RBRACE ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {COMMA RBRACE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT COMMA RBRACE EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {COMMA RBRACE OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_initializer ::= (*) lbrace_multiline variable_initializers COMMA rbrace_multiline , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {COMMA RBRACE AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {COMMA RBRACE OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RBRACE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [variable_initializer ::= (*) expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_initializer ::= (*) lbrace_multiline variable_initializers rbrace_multiline , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {COMMA RBRACE AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {COMMA RBRACE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [variable_initializer ::= (*) array_initializer , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [array_initializer ::= (*) lbrace_multiline comma_multiline rbrace_multiline , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RBRACE XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {COMMA RBRACE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_initializer ::= (*) lbrace_multiline rbrace_multiline , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {COMMA RBRACE XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {COMMA RBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RBRACE OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {COMMA RBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [variable_initializers ::= variable_initializers comma_multiline (*) variable_initializer , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {COMMA RBRACE OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on LBRACE to state [47]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on array_initializer to state [315]
transition on variable_initializer to state [322]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on postdecrement_expression to state [190]
transition on MINUSMINUS to state [162]
transition on unary_expression to state [189]
transition on expression to state [313]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on lbrace_multiline to state [309]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [321]: {
  [array_initializer ::= lbrace_multiline variable_initializers rbrace_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [322]: {
  [variable_initializers ::= variable_initializers comma_multiline variable_initializer (*) , {COMMA RBRACE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [323]: {
  [array_initializer ::= lbrace_multiline variable_initializers COMMA rbrace_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [324]: {
  [rbrace_multiline ::= terminators_opt (*) RBRACE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [comma_multiline ::= COMMA terminators_opt (*) , {LBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on RBRACE to state [318]

-------------------
lalr_state [325]: {
  [array_creation_expression ::= NEW primitive_type dim_exprs dims_opt (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [326]: {
  [dim_exprs ::= dim_exprs dim_expr (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [327]: {
  [dims_opt ::= dims (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dims ::= dims (*) lbrack_multiline rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lbrack_multiline ::= (*) LBRACK terminators_opt , {RBRACK NEWLINE ENDOFFILE }]
}
transition on LBRACK to state [77]
transition on lbrack_multiline to state [79]

-------------------
lalr_state [328]: {
  [terminator ::= (*) NEWLINE , {RBRACK NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RBRACK }]
  [rbrack_multiline ::= (*) terminators_opt RBRACK , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RBRACK }]
  [terminators_opt ::= (*) , {RBRACK }]
  [terminator ::= (*) ENDOFFILE , {RBRACK NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RBRACK }]
  [dim_expr ::= lbrack_multiline expression (*) rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [81]
transition on rbrack_multiline to state [329]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [329]: {
  [dim_expr ::= lbrack_multiline expression rbrack_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [330]: {
  [dim_expr ::= (*) lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dims_opt ::= (*) dims , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dim_exprs ::= dim_exprs (*) dim_expr , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dims ::= (*) dims lbrack_multiline rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lbrack_multiline ::= (*) LBRACK terminators_opt , {RBRACK LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= NEW class_or_interface_type dim_exprs (*) dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dims_opt ::= (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dims ::= (*) lbrack_multiline rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on dims to state [327]
transition on LBRACK to state [77]
transition on lbrack_multiline to state [305]
transition on dim_expr to state [326]
transition on dims_opt to state [333]

-------------------
lalr_state [331]: {
  [array_initializer ::= (*) lbrace_multiline variable_initializers rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {COMMA LBRACE RBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [array_initializer ::= (*) lbrace_multiline rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_initializer ::= (*) lbrace_multiline variable_initializers COMMA rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [dims ::= dims (*) lbrack_multiline rbrack_multiline , {LBRACK LBRACE }]
  [lbrack_multiline ::= (*) LBRACK terminators_opt , {RBRACK NEWLINE ENDOFFILE }]
  [array_initializer ::= (*) lbrace_multiline comma_multiline rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= NEW class_or_interface_type dims (*) array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on lbrace_multiline to state [309]
transition on LBRACK to state [77]
transition on lbrack_multiline to state [79]
transition on LBRACE to state [47]
transition on array_initializer to state [332]

-------------------
lalr_state [332]: {
  [array_creation_expression ::= NEW class_or_interface_type dims array_initializer (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [333]: {
  [array_creation_expression ::= NEW class_or_interface_type dim_exprs dims_opt (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [334]: {
  [terminator ::= (*) NEWLINE , {RPAREN NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RPAREN }]
  [primary_no_new_array ::= lparen_multiline expression (*) rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RPAREN }]
  [rparen_multiline ::= (*) terminators_opt RPAREN , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {RPAREN }]
  [terminator ::= (*) ENDOFFILE , {RPAREN NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RPAREN }]
}
transition on NEWLINE to state [43]
transition on rparen_multiline to state [335]
transition on terminators_opt to state [98]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [335]: {
  [primary_no_new_array ::= lparen_multiline expression rparen_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [336]: {
  [preincrement_expression ::= PLUSPLUS unary_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [337]: {
  [array_access ::= primary_no_new_array lbrack_multiline (*) expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {RBRACK NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {RBRACK LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {RBRACK EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {RBRACK NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {RBRACK ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {RBRACK LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {RBRACK EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK RBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {RBRACK ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {RBRACK EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK RBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {RBRACK OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {RBRACK AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK RBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {RBRACK OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {RBRACK PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {RBRACK AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {RBRACK NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {RBRACK PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {RBRACK XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {RBRACK NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {RBRACK PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {RBRACK XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {RBRACK NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {RBRACK LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {RBRACK OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {RBRACK NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {RBRACK LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {RBRACK OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on expression to state [338]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [338]: {
  [array_access ::= primary_no_new_array lbrack_multiline expression (*) rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) NEWLINE , {RBRACK NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RBRACK }]
  [rbrack_multiline ::= (*) terminators_opt RBRACK , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RBRACK }]
  [terminators_opt ::= (*) , {RBRACK }]
  [terminator ::= (*) ENDOFFILE , {RBRACK NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RBRACK }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [81]
transition on rbrack_multiline to state [339]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [339]: {
  [array_access ::= primary_no_new_array lbrack_multiline expression rbrack_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [340]: {
  [predecrement_expression ::= MINUSMINUS unary_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [341]: {
  [terminator ::= (*) NEWLINE , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= IF expression (*) terminators statement_no_short_if ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [if_then_statement ::= IF expression (*) terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [342]

-------------------
lalr_state [342]: {
  [labeled_statement_no_short_if ::= (*) IDENTIFIER colon_multiline statement_no_short_if , {ELSE }]
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [if_then_statement ::= IF expression terminators (*) statement , {WHILE NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [if_then_statement ::= (*) IF expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_no_short_if ::= (*) statement_without_trailing_substatement , {ELSE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [throw_statement ::= (*) THROW expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) do_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [do_statement ::= (*) DO terminators_opt statement terminators_opt WHILE expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [expression_statement ::= (*) statement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [if_then_else_statement ::= IF expression terminators (*) statement_no_short_if ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_no_short_if ::= (*) labeled_statement_no_short_if , {ELSE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [try_statement ::= (*) TRY block terminators_opt catches , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) break_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) assignment , {ELSE WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [if_then_else_statement_no_short_if ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement_no_short_if , {ELSE }]
  [statement_no_short_if ::= (*) if_then_else_statement_no_short_if , {ELSE }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt catches terminators_opt finally , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) continue_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement_no_short_if ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement_no_short_if , {ELSE }]
  [statement_expression ::= (*) preincrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) statement_without_trailing_substatement , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [switch_statement ::= (*) SWITCH expression switch_block , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_no_short_if ::= (*) while_statement_no_short_if , {ELSE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt finally , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) return_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) predecrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) labeled_statement , {WHILE NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [statement_no_short_if ::= (*) for_statement_no_short_if , {ELSE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) throw_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postincrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_statement , {WHILE NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_without_trailing_substatement ::= (*) block , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) try_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postdecrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_else_statement , {WHILE NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [break_statement ::= (*) BREAK identifier_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) empty_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [empty_statement ::= (*) PASS , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) method_invocation , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) while_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [continue_statement ::= (*) CONTINUE identifier_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) expression_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [while_statement ::= (*) WHILE expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [labeled_statement ::= (*) IDENTIFIER colon_multiline statement , {WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) class_instance_creation_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) for_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [return_statement ::= (*) RETURN expression_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) switch_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
  [while_statement_no_short_if ::= (*) WHILE expression terminators statement_no_short_if , {ELSE }]
}
transition on IDENTIFIER to state [353]
transition on DO to state [141]
transition on array_access to state [112]
transition on labeled_statement to state [157]
transition on if_then_else_statement to state [158]
transition on expression_statement to state [145]
transition on preincrement_expression to state [131]
transition on statement_without_trailing_substatement to state [352]
transition on try_statement to state [118]
transition on UNDEFINED_LITERAL to state [128]
transition on while_statement_no_short_if to state [351]
transition on WHILE to state [350]
transition on method_invocation to state [108]
transition on while_statement to state [153]
transition on LBRACE to state [47]
transition on primary_no_new_array to state [164]
transition on throw_statement to state [161]
transition on class_instance_creation_expression to state [119]
transition on SWITCH to state [140]
transition on postfix_expression to state [122]
transition on BREAK to state [146]
transition on return_statement to state [133]
transition on TRY to state [144]
transition on do_statement to state [170]
transition on continue_statement to state [155]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on postdecrement_expression to state [121]
transition on MINUSMINUS to state [162]
transition on RETURN to state [143]
transition on statement to state [349]
transition on qualified_name to state [35]
transition on for_statement_no_short_if to state [348]
transition on THIS to state [150]
transition on IF to state [347]
transition on NULL_LITERAL to state [148]
transition on primary to state [154]
transition on assignment to state [152]
transition on THROW to state [116]
transition on PASS to state [115]
transition on lparen_multiline to state [166]
transition on empty_statement to state [132]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on for_statement to state [107]
transition on lbrace_multiline to state [104]
transition on FOR to state [346]
transition on statement_no_short_if to state [345]
transition on block to state [120]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [156]
transition on LPAREN to state [89]
transition on CONTINUE to state [159]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [163]
transition on if_then_else_statement_no_short_if to state [344]
transition on switch_statement to state [111]
transition on break_statement to state [126]
transition on labeled_statement_no_short_if to state [343]
transition on left_hand_side to state [113]
transition on if_then_statement to state [135]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]
transition on statement_expression to state [117]

-------------------
lalr_state [343]: {
  [statement_no_short_if ::= labeled_statement_no_short_if (*) , {ELSE }]
}

-------------------
lalr_state [344]: {
  [statement_no_short_if ::= if_then_else_statement_no_short_if (*) , {ELSE }]
}

-------------------
lalr_state [345]: {
  [if_then_else_statement ::= IF expression terminators statement_no_short_if (*) ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
}
transition on ELSE to state [387]

-------------------
lalr_state [346]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {SEMICOLON COMMA }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primitive_type ::= (*) BOOLEAN , {LBRACK IDENTIFIER }]
  [array_type ::= (*) ARRAY , {IDENTIFIER }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [primitive_type ::= (*) OBJECT , {LBRACK IDENTIFIER }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [for_statement ::= FOR (*) for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) assignment , {SEMICOLON COMMA }]
  [local_variable_declaration ::= (*) type variable_declarators , {SEMICOLON }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS }]
  [reference_type ::= (*) class_or_interface_type , {IDENTIFIER }]
  [statement_expression_list ::= (*) statement_expression , {SEMICOLON COMMA }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [for_statement_no_short_if ::= FOR (*) for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement_no_short_if , {ELSE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) preincrement_expression , {SEMICOLON COMMA }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [reference_type ::= (*) array_type , {IDENTIFIER }]
  [statement_expression_list ::= (*) statement_expression_list comma_multiline statement_expression , {SEMICOLON COMMA }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {SEMICOLON COMMA }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [type ::= (*) primitive_type , {IDENTIFIER }]
  [for_init_opt ::= (*) , {SEMICOLON }]
  [statement_expression ::= (*) predecrement_expression , {SEMICOLON COMMA }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [class_or_interface_type ::= (*) name , {IDENTIFIER }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {SEMICOLON COMMA }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS }]
  [type ::= (*) reference_type , {IDENTIFIER }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_init_opt ::= (*) for_init , {SEMICOLON }]
  [statement_expression ::= (*) postincrement_expression , {SEMICOLON COMMA }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {SEMICOLON COMMA PLUSPLUS MINUSMINUS }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [type ::= (*) VAR , {IDENTIFIER }]
  [for_init ::= (*) statement_expression_list , {SEMICOLON }]
  [statement_expression ::= (*) postdecrement_expression , {SEMICOLON COMMA }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {SEMICOLON COMMA PLUSPLUS MINUSMINUS }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primitive_type ::= (*) NUMBER , {LBRACK IDENTIFIER }]
  [for_init ::= (*) local_variable_declaration , {SEMICOLON }]
  [statement_expression ::= (*) method_invocation , {SEMICOLON COMMA }]
  [array_type ::= (*) primitive_type dims , {IDENTIFIER }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primitive_type ::= (*) STRING , {LBRACK IDENTIFIER }]
  [statement_expression ::= (*) class_instance_creation_expression , {SEMICOLON COMMA }]
  [array_type ::= (*) name dims , {IDENTIFIER }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
}
transition on type to state [138]
transition on IDENTIFIER to state [34]
transition on for_init to state [372]
transition on VAR to state [74]
transition on array_access to state [112]
transition on class_or_interface_type to state [62]
transition on for_init_opt to state [371]
transition on STRING to state [67]
transition on preincrement_expression to state [131]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [108]
transition on primary_no_new_array to state [164]
transition on reference_type to state [68]
transition on class_instance_creation_expression to state [119]
transition on primitive_type to state [71]
transition on postfix_expression to state [122]
transition on NUMBER to state [69]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [121]
transition on BOOLEAN to state [66]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on primary to state [154]
transition on statement_expression_list to state [370]
transition on assignment to state [152]
transition on OBJECT to state [65]
transition on lparen_multiline to state [166]
transition on array_type to state [72]
transition on local_variable_declaration to state [369]
transition on name to state [147]
transition on BOOLEAN_LITERAL to state [129]
transition on ARRAY to state [73]
transition on array_creation_expression to state [137]
transition on predecrement_expression to state [156]
transition on literal to state [169]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [163]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]
transition on statement_expression to state [368]

-------------------
lalr_state [347]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [if_then_statement ::= IF (*) expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= IF (*) expression terminators statement_no_short_if ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [if_then_else_statement_no_short_if ::= IF (*) expression terminators statement_no_short_if ELSE terminators_opt statement_no_short_if , {ELSE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on expression to state [361]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [348]: {
  [statement_no_short_if ::= for_statement_no_short_if (*) , {ELSE }]
}

-------------------
lalr_state [349]: {
  [if_then_statement ::= IF expression terminators statement (*) , {WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [350]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [while_statement ::= WHILE (*) expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [while_statement_no_short_if ::= WHILE (*) expression terminators statement_no_short_if , {ELSE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on class_instance_creation_expression to state [196]
transition on conditional_or_expression to state [197]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on expression to state [357]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [351]: {
  [statement_no_short_if ::= while_statement_no_short_if (*) , {ELSE }]
}

-------------------
lalr_state [352]: {
  [statement_no_short_if ::= statement_without_trailing_substatement (*) , {ELSE }]
  [statement ::= statement_without_trailing_substatement (*) , {WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [353]: {
  [labeled_statement ::= IDENTIFIER (*) colon_multiline statement , {WHILE NEWLINE ENDOFFILE }]
  [name ::= IDENTIFIER (*) , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [colon_multiline ::= (*) COLON terminators_opt , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [labeled_statement_no_short_if ::= IDENTIFIER (*) colon_multiline statement_no_short_if , {ELSE }]
}
transition on colon_multiline to state [354]
transition on COLON to state [290]

-------------------
lalr_state [354]: {
  [labeled_statement_no_short_if ::= (*) IDENTIFIER colon_multiline statement_no_short_if , {ELSE }]
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [if_then_statement ::= (*) IF expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_no_short_if ::= (*) statement_without_trailing_substatement , {ELSE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [throw_statement ::= (*) THROW expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) do_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [do_statement ::= (*) DO terminators_opt statement terminators_opt WHILE expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [expression_statement ::= (*) statement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_no_short_if ::= (*) labeled_statement_no_short_if , {ELSE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [try_statement ::= (*) TRY block terminators_opt catches , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) break_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) assignment , {ELSE WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [if_then_else_statement_no_short_if ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement_no_short_if , {ELSE }]
  [statement_no_short_if ::= (*) if_then_else_statement_no_short_if , {ELSE }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt catches terminators_opt finally , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) continue_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement_no_short_if ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement_no_short_if , {ELSE }]
  [statement_expression ::= (*) preincrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) statement_without_trailing_substatement , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [switch_statement ::= (*) SWITCH expression switch_block , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_no_short_if ::= (*) while_statement_no_short_if , {ELSE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt finally , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) return_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) predecrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) labeled_statement , {WHILE NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [statement_no_short_if ::= (*) for_statement_no_short_if , {ELSE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) throw_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postincrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_statement , {WHILE NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_without_trailing_substatement ::= (*) block , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) try_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postdecrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_else_statement , {WHILE NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [break_statement ::= (*) BREAK identifier_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) empty_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [empty_statement ::= (*) PASS , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) method_invocation , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) while_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [continue_statement ::= (*) CONTINUE identifier_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) expression_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [labeled_statement ::= IDENTIFIER colon_multiline (*) statement , {WHILE NEWLINE ENDOFFILE }]
  [while_statement ::= (*) WHILE expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [labeled_statement ::= (*) IDENTIFIER colon_multiline statement , {WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) class_instance_creation_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) for_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [return_statement ::= (*) RETURN expression_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) switch_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
  [labeled_statement_no_short_if ::= IDENTIFIER colon_multiline (*) statement_no_short_if , {ELSE }]
  [while_statement_no_short_if ::= (*) WHILE expression terminators statement_no_short_if , {ELSE }]
}
transition on IDENTIFIER to state [353]
transition on DO to state [141]
transition on array_access to state [112]
transition on labeled_statement to state [157]
transition on if_then_else_statement to state [158]
transition on expression_statement to state [145]
transition on preincrement_expression to state [131]
transition on statement_without_trailing_substatement to state [352]
transition on try_statement to state [118]
transition on UNDEFINED_LITERAL to state [128]
transition on while_statement_no_short_if to state [351]
transition on WHILE to state [350]
transition on method_invocation to state [108]
transition on while_statement to state [153]
transition on LBRACE to state [47]
transition on primary_no_new_array to state [164]
transition on throw_statement to state [161]
transition on class_instance_creation_expression to state [119]
transition on SWITCH to state [140]
transition on postfix_expression to state [122]
transition on BREAK to state [146]
transition on return_statement to state [133]
transition on TRY to state [144]
transition on do_statement to state [170]
transition on continue_statement to state [155]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on postdecrement_expression to state [121]
transition on MINUSMINUS to state [162]
transition on RETURN to state [143]
transition on statement to state [356]
transition on qualified_name to state [35]
transition on for_statement_no_short_if to state [348]
transition on THIS to state [150]
transition on IF to state [347]
transition on NULL_LITERAL to state [148]
transition on primary to state [154]
transition on assignment to state [152]
transition on THROW to state [116]
transition on PASS to state [115]
transition on lparen_multiline to state [166]
transition on empty_statement to state [132]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on for_statement to state [107]
transition on lbrace_multiline to state [104]
transition on FOR to state [346]
transition on block to state [120]
transition on statement_no_short_if to state [355]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [156]
transition on LPAREN to state [89]
transition on CONTINUE to state [159]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [163]
transition on if_then_else_statement_no_short_if to state [344]
transition on switch_statement to state [111]
transition on break_statement to state [126]
transition on labeled_statement_no_short_if to state [343]
transition on left_hand_side to state [113]
transition on if_then_statement to state [135]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]
transition on statement_expression to state [117]

-------------------
lalr_state [355]: {
  [labeled_statement_no_short_if ::= IDENTIFIER colon_multiline statement_no_short_if (*) , {ELSE }]
}

-------------------
lalr_state [356]: {
  [labeled_statement ::= IDENTIFIER colon_multiline statement (*) , {WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [357]: {
  [terminator ::= (*) NEWLINE , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [while_statement_no_short_if ::= WHILE expression (*) terminators statement_no_short_if , {ELSE }]
  [terminators ::= (*) terminator terminators , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [while_statement ::= WHILE expression (*) terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [358]

-------------------
lalr_state [358]: {
  [labeled_statement_no_short_if ::= (*) IDENTIFIER colon_multiline statement_no_short_if , {ELSE }]
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [if_then_statement ::= (*) IF expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_no_short_if ::= (*) statement_without_trailing_substatement , {ELSE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [throw_statement ::= (*) THROW expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) do_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [do_statement ::= (*) DO terminators_opt statement terminators_opt WHILE expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [expression_statement ::= (*) statement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_no_short_if ::= (*) labeled_statement_no_short_if , {ELSE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [try_statement ::= (*) TRY block terminators_opt catches , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) break_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) assignment , {ELSE WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [if_then_else_statement_no_short_if ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement_no_short_if , {ELSE }]
  [statement_no_short_if ::= (*) if_then_else_statement_no_short_if , {ELSE }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt catches terminators_opt finally , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) continue_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement_no_short_if ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement_no_short_if , {ELSE }]
  [statement_expression ::= (*) preincrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) statement_without_trailing_substatement , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [switch_statement ::= (*) SWITCH expression switch_block , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_no_short_if ::= (*) while_statement_no_short_if , {ELSE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt finally , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) return_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) predecrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) labeled_statement , {WHILE NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [statement_no_short_if ::= (*) for_statement_no_short_if , {ELSE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) throw_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postincrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_statement , {WHILE NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_without_trailing_substatement ::= (*) block , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) try_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postdecrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_else_statement , {WHILE NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [break_statement ::= (*) BREAK identifier_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) empty_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [empty_statement ::= (*) PASS , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) method_invocation , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) while_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [continue_statement ::= (*) CONTINUE identifier_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) expression_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [while_statement ::= WHILE expression terminators (*) statement , {WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [while_statement ::= (*) WHILE expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [labeled_statement ::= (*) IDENTIFIER colon_multiline statement , {WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) class_instance_creation_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) for_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [return_statement ::= (*) RETURN expression_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) switch_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [while_statement_no_short_if ::= WHILE expression terminators (*) statement_no_short_if , {ELSE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
  [while_statement_no_short_if ::= (*) WHILE expression terminators statement_no_short_if , {ELSE }]
}
transition on IDENTIFIER to state [353]
transition on DO to state [141]
transition on array_access to state [112]
transition on labeled_statement to state [157]
transition on if_then_else_statement to state [158]
transition on expression_statement to state [145]
transition on preincrement_expression to state [131]
transition on statement_without_trailing_substatement to state [352]
transition on try_statement to state [118]
transition on UNDEFINED_LITERAL to state [128]
transition on while_statement_no_short_if to state [351]
transition on WHILE to state [350]
transition on method_invocation to state [108]
transition on while_statement to state [153]
transition on LBRACE to state [47]
transition on primary_no_new_array to state [164]
transition on throw_statement to state [161]
transition on class_instance_creation_expression to state [119]
transition on SWITCH to state [140]
transition on postfix_expression to state [122]
transition on BREAK to state [146]
transition on return_statement to state [133]
transition on TRY to state [144]
transition on do_statement to state [170]
transition on continue_statement to state [155]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on postdecrement_expression to state [121]
transition on MINUSMINUS to state [162]
transition on RETURN to state [143]
transition on statement to state [360]
transition on qualified_name to state [35]
transition on for_statement_no_short_if to state [348]
transition on THIS to state [150]
transition on IF to state [347]
transition on NULL_LITERAL to state [148]
transition on primary to state [154]
transition on assignment to state [152]
transition on THROW to state [116]
transition on PASS to state [115]
transition on lparen_multiline to state [166]
transition on empty_statement to state [132]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on for_statement to state [107]
transition on lbrace_multiline to state [104]
transition on FOR to state [346]
transition on block to state [120]
transition on statement_no_short_if to state [359]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [156]
transition on LPAREN to state [89]
transition on CONTINUE to state [159]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [163]
transition on if_then_else_statement_no_short_if to state [344]
transition on switch_statement to state [111]
transition on break_statement to state [126]
transition on labeled_statement_no_short_if to state [343]
transition on left_hand_side to state [113]
transition on if_then_statement to state [135]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]
transition on statement_expression to state [117]

-------------------
lalr_state [359]: {
  [while_statement_no_short_if ::= WHILE expression terminators statement_no_short_if (*) , {ELSE }]
}

-------------------
lalr_state [360]: {
  [while_statement ::= WHILE expression terminators statement (*) , {WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [361]: {
  [terminator ::= (*) NEWLINE , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= IF expression (*) terminators statement_no_short_if ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [if_then_statement ::= IF expression (*) terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [if_then_else_statement_no_short_if ::= IF expression (*) terminators statement_no_short_if ELSE terminators_opt statement_no_short_if , {ELSE }]
  [terminators ::= (*) terminator , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [362]

-------------------
lalr_state [362]: {
  [labeled_statement_no_short_if ::= (*) IDENTIFIER colon_multiline statement_no_short_if , {ELSE }]
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [if_then_statement ::= IF expression terminators (*) statement , {WHILE NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [if_then_statement ::= (*) IF expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_no_short_if ::= (*) statement_without_trailing_substatement , {ELSE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [throw_statement ::= (*) THROW expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) do_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [do_statement ::= (*) DO terminators_opt statement terminators_opt WHILE expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [expression_statement ::= (*) statement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [if_then_else_statement ::= IF expression terminators (*) statement_no_short_if ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_no_short_if ::= (*) labeled_statement_no_short_if , {ELSE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [try_statement ::= (*) TRY block terminators_opt catches , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) break_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) assignment , {ELSE WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [if_then_else_statement_no_short_if ::= IF expression terminators (*) statement_no_short_if ELSE terminators_opt statement_no_short_if , {ELSE }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [if_then_else_statement_no_short_if ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement_no_short_if , {ELSE }]
  [statement_no_short_if ::= (*) if_then_else_statement_no_short_if , {ELSE }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt catches terminators_opt finally , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) continue_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement_no_short_if ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement_no_short_if , {ELSE }]
  [statement_expression ::= (*) preincrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) statement_without_trailing_substatement , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [switch_statement ::= (*) SWITCH expression switch_block , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_no_short_if ::= (*) while_statement_no_short_if , {ELSE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt finally , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) return_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) predecrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) labeled_statement , {WHILE NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [statement_no_short_if ::= (*) for_statement_no_short_if , {ELSE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) throw_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postincrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_statement , {WHILE NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_without_trailing_substatement ::= (*) block , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) try_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postdecrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_else_statement , {WHILE NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [break_statement ::= (*) BREAK identifier_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) empty_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [empty_statement ::= (*) PASS , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) method_invocation , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) while_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [continue_statement ::= (*) CONTINUE identifier_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) expression_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [while_statement ::= (*) WHILE expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [labeled_statement ::= (*) IDENTIFIER colon_multiline statement , {WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) class_instance_creation_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) for_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [return_statement ::= (*) RETURN expression_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) switch_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
  [while_statement_no_short_if ::= (*) WHILE expression terminators statement_no_short_if , {ELSE }]
}
transition on IDENTIFIER to state [353]
transition on DO to state [141]
transition on array_access to state [112]
transition on labeled_statement to state [157]
transition on if_then_else_statement to state [158]
transition on expression_statement to state [145]
transition on preincrement_expression to state [131]
transition on statement_without_trailing_substatement to state [352]
transition on try_statement to state [118]
transition on UNDEFINED_LITERAL to state [128]
transition on while_statement_no_short_if to state [351]
transition on WHILE to state [350]
transition on method_invocation to state [108]
transition on while_statement to state [153]
transition on LBRACE to state [47]
transition on primary_no_new_array to state [164]
transition on throw_statement to state [161]
transition on class_instance_creation_expression to state [119]
transition on SWITCH to state [140]
transition on postfix_expression to state [122]
transition on BREAK to state [146]
transition on return_statement to state [133]
transition on TRY to state [144]
transition on do_statement to state [170]
transition on continue_statement to state [155]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on postdecrement_expression to state [121]
transition on MINUSMINUS to state [162]
transition on RETURN to state [143]
transition on statement to state [349]
transition on qualified_name to state [35]
transition on for_statement_no_short_if to state [348]
transition on THIS to state [150]
transition on IF to state [347]
transition on NULL_LITERAL to state [148]
transition on primary to state [154]
transition on assignment to state [152]
transition on THROW to state [116]
transition on PASS to state [115]
transition on lparen_multiline to state [166]
transition on empty_statement to state [132]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on for_statement to state [107]
transition on lbrace_multiline to state [104]
transition on FOR to state [346]
transition on statement_no_short_if to state [363]
transition on block to state [120]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [156]
transition on LPAREN to state [89]
transition on CONTINUE to state [159]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [163]
transition on if_then_else_statement_no_short_if to state [344]
transition on switch_statement to state [111]
transition on break_statement to state [126]
transition on labeled_statement_no_short_if to state [343]
transition on left_hand_side to state [113]
transition on if_then_statement to state [135]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]
transition on statement_expression to state [117]

-------------------
lalr_state [363]: {
  [if_then_else_statement_no_short_if ::= IF expression terminators statement_no_short_if (*) ELSE terminators_opt statement_no_short_if , {ELSE }]
  [if_then_else_statement ::= IF expression terminators statement_no_short_if (*) ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
}
transition on ELSE to state [364]

-------------------
lalr_state [364]: {
  [terminator ::= (*) NEWLINE , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [if_then_else_statement_no_short_if ::= IF expression terminators statement_no_short_if ELSE (*) terminators_opt statement_no_short_if , {ELSE }]
  [terminators_opt ::= (*) , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [if_then_else_statement ::= IF expression terminators statement_no_short_if ELSE (*) terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [365]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [365]: {
  [labeled_statement_no_short_if ::= (*) IDENTIFIER colon_multiline statement_no_short_if , {ELSE }]
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [if_then_statement ::= (*) IF expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_no_short_if ::= (*) statement_without_trailing_substatement , {ELSE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [throw_statement ::= (*) THROW expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) do_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [do_statement ::= (*) DO terminators_opt statement terminators_opt WHILE expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [expression_statement ::= (*) statement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= IF expression terminators statement_no_short_if ELSE terminators_opt (*) statement , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_no_short_if ::= (*) labeled_statement_no_short_if , {ELSE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [try_statement ::= (*) TRY block terminators_opt catches , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) break_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) assignment , {ELSE WHILE NEWLINE ENDOFFILE }]
  [if_then_else_statement_no_short_if ::= IF expression terminators statement_no_short_if ELSE terminators_opt (*) statement_no_short_if , {ELSE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [if_then_else_statement_no_short_if ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement_no_short_if , {ELSE }]
  [statement_no_short_if ::= (*) if_then_else_statement_no_short_if , {ELSE }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt catches terminators_opt finally , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) continue_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement_no_short_if ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement_no_short_if , {ELSE }]
  [statement_expression ::= (*) preincrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) statement_without_trailing_substatement , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [switch_statement ::= (*) SWITCH expression switch_block , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_no_short_if ::= (*) while_statement_no_short_if , {ELSE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt finally , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) return_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) predecrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) labeled_statement , {WHILE NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [statement_no_short_if ::= (*) for_statement_no_short_if , {ELSE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) throw_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postincrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_statement , {WHILE NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_without_trailing_substatement ::= (*) block , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) try_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postdecrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_else_statement , {WHILE NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [break_statement ::= (*) BREAK identifier_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) empty_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [empty_statement ::= (*) PASS , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) method_invocation , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) while_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [continue_statement ::= (*) CONTINUE identifier_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) expression_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [while_statement ::= (*) WHILE expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [labeled_statement ::= (*) IDENTIFIER colon_multiline statement , {WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) class_instance_creation_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) for_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [return_statement ::= (*) RETURN expression_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) switch_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
  [while_statement_no_short_if ::= (*) WHILE expression terminators statement_no_short_if , {ELSE }]
}
transition on IDENTIFIER to state [353]
transition on DO to state [141]
transition on array_access to state [112]
transition on labeled_statement to state [157]
transition on if_then_else_statement to state [158]
transition on expression_statement to state [145]
transition on preincrement_expression to state [131]
transition on statement_without_trailing_substatement to state [352]
transition on try_statement to state [118]
transition on UNDEFINED_LITERAL to state [128]
transition on while_statement_no_short_if to state [351]
transition on WHILE to state [350]
transition on method_invocation to state [108]
transition on while_statement to state [153]
transition on LBRACE to state [47]
transition on primary_no_new_array to state [164]
transition on throw_statement to state [161]
transition on class_instance_creation_expression to state [119]
transition on SWITCH to state [140]
transition on postfix_expression to state [122]
transition on BREAK to state [146]
transition on return_statement to state [133]
transition on TRY to state [144]
transition on do_statement to state [170]
transition on continue_statement to state [155]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on postdecrement_expression to state [121]
transition on MINUSMINUS to state [162]
transition on RETURN to state [143]
transition on statement to state [367]
transition on qualified_name to state [35]
transition on for_statement_no_short_if to state [348]
transition on THIS to state [150]
transition on IF to state [347]
transition on NULL_LITERAL to state [148]
transition on primary to state [154]
transition on assignment to state [152]
transition on THROW to state [116]
transition on PASS to state [115]
transition on lparen_multiline to state [166]
transition on empty_statement to state [132]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on for_statement to state [107]
transition on lbrace_multiline to state [104]
transition on FOR to state [346]
transition on statement_no_short_if to state [366]
transition on block to state [120]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [156]
transition on LPAREN to state [89]
transition on CONTINUE to state [159]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [163]
transition on if_then_else_statement_no_short_if to state [344]
transition on switch_statement to state [111]
transition on break_statement to state [126]
transition on labeled_statement_no_short_if to state [343]
transition on left_hand_side to state [113]
transition on if_then_statement to state [135]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]
transition on statement_expression to state [117]

-------------------
lalr_state [366]: {
  [if_then_else_statement_no_short_if ::= IF expression terminators statement_no_short_if ELSE terminators_opt statement_no_short_if (*) , {ELSE }]
}

-------------------
lalr_state [367]: {
  [if_then_else_statement ::= IF expression terminators statement_no_short_if ELSE terminators_opt statement (*) , {WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [368]: {
  [statement_expression_list ::= statement_expression (*) , {SEMICOLON COMMA NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [369]: {
  [for_init ::= local_variable_declaration (*) , {SEMICOLON }]
}

-------------------
lalr_state [370]: {
  [comma_multiline ::= (*) COMMA terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_expression_list ::= statement_expression_list (*) comma_multiline statement_expression , {SEMICOLON COMMA }]
  [for_init ::= statement_expression_list (*) , {SEMICOLON }]
}
transition on comma_multiline to state [381]
transition on COMMA to state [36]

-------------------
lalr_state [371]: {
  [for_statement_no_short_if ::= FOR for_init_opt (*) semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement_no_short_if , {ELSE }]
  [semicolon_multiline ::= (*) SEMICOLON terminators_opt , {SEMICOLON LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [for_statement ::= FOR for_init_opt (*) semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
}
transition on semicolon_multiline to state [374]
transition on SEMICOLON to state [373]

-------------------
lalr_state [372]: {
  [for_init_opt ::= for_init (*) , {SEMICOLON }]
}

-------------------
lalr_state [373]: {
  [terminator ::= (*) NEWLINE , {SEMICOLON LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {SEMICOLON LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [semicolon_multiline ::= SEMICOLON (*) terminators_opt , {SEMICOLON LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {SEMICOLON LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {SEMICOLON LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {SEMICOLON LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {SEMICOLON LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [386]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [374]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {SEMICOLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT SEMICOLON MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [equality_expression ::= (*) relational_expression , {SEMICOLON EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) PLUS unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [expression ::= (*) assignment_expression , {SEMICOLON }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {SEMICOLON ANDAND OROR QUESTION }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT SEMICOLON MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary ::= (*) array_creation_expression , {DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {SEMICOLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) primary , {SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {SEMICOLON EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) MINUS unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT SEMICOLON MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {SEMICOLON ANDAND OROR QUESTION }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [for_statement ::= FOR for_init_opt semicolon_multiline (*) expression_opt semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT SEMICOLON MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {SEMICOLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) name , {SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {SEMICOLON EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [name ::= (*) qualified_name , {LBRACK DOT SEMICOLON MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [conditional_or_expression ::= (*) conditional_and_expression , {SEMICOLON OROR QUESTION }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [for_statement_no_short_if ::= FOR for_init_opt semicolon_multiline (*) expression_opt semicolon_multiline for_update_opt terminators statement_no_short_if , {ELSE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT SEMICOLON MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {SEMICOLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) postincrement_expression , {SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [and_expression ::= (*) equality_expression , {SEMICOLON AND XOR OR ANDAND OROR QUESTION }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT SEMICOLON MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {SEMICOLON OROR QUESTION }]
  [additive_expression ::= (*) multiplicative_expression , {SEMICOLON PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {SEMICOLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) postdecrement_expression , {SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {SEMICOLON AND XOR OR ANDAND OROR QUESTION }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [conditional_expression ::= (*) conditional_or_expression , {SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {SEMICOLON PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {SEMICOLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {SEMICOLON XOR OR ANDAND OROR QUESTION }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {SEMICOLON PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {SEMICOLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {SEMICOLON XOR OR ANDAND OROR QUESTION }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [assignment_expression ::= (*) conditional_expression , {SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {SEMICOLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {SEMICOLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) preincrement_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [expression_opt ::= (*) , {SEMICOLON }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {SEMICOLON OR ANDAND OROR QUESTION }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [assignment_expression ::= (*) assignment , {SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {SEMICOLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT SEMICOLON MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {SEMICOLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) predecrement_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [expression_opt ::= (*) expression , {SEMICOLON }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {SEMICOLON OR ANDAND OROR QUESTION }]
  [multiplicative_expression ::= (*) unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary ::= (*) primary_no_new_array , {DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on expression_opt to state [376]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on expression to state [375]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [375]: {
  [expression_opt ::= expression (*) , {SEMICOLON ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [376]: {
  [for_statement_no_short_if ::= FOR for_init_opt semicolon_multiline expression_opt (*) semicolon_multiline for_update_opt terminators statement_no_short_if , {ELSE }]
  [semicolon_multiline ::= (*) SEMICOLON terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [for_statement ::= FOR for_init_opt semicolon_multiline expression_opt (*) semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
}
transition on semicolon_multiline to state [377]
transition on SEMICOLON to state [373]

-------------------
lalr_state [377]: {
  [statement_expression ::= (*) method_invocation , {COMMA NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_expression ::= (*) preincrement_expression , {COMMA NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {COMMA NEWLINE ENDOFFILE }]
  [for_update_opt ::= (*) for_update , {NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) class_instance_creation_expression , {COMMA NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {COMMA NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) predecrement_expression , {COMMA NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [for_update ::= (*) statement_expression_list , {NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postincrement_expression , {COMMA NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {COMMA NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [for_statement ::= FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline (*) for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [statement_expression_list ::= (*) statement_expression , {COMMA NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postdecrement_expression , {COMMA NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [for_statement_no_short_if ::= FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline (*) for_update_opt terminators statement_no_short_if , {ELSE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [statement_expression_list ::= (*) statement_expression_list comma_multiline statement_expression , {COMMA NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) assignment , {COMMA NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
  [for_update_opt ::= (*) , {NEWLINE ENDOFFILE }]
}
transition on name to state [180]
transition on NULL_LITERAL to state [148]
transition on SUPER to state [134]
transition on array_access to state [112]
transition on NEW to state [167]
transition on literal to state [169]
transition on statement_expression_list to state [380]
transition on array_creation_expression to state [137]
transition on PLUSPLUS to state [165]
transition on qualified_name to state [35]
transition on primary to state [154]
transition on assignment to state [152]
transition on primary_no_new_array to state [164]
transition on NUMBER_LITERAL to state [127]
transition on postdecrement_expression to state [121]
transition on for_update_opt to state [379]
transition on STRING_LITERAL to state [149]
transition on postfix_expression to state [122]
transition on THIS to state [150]
transition on LPAREN to state [89]
transition on preincrement_expression to state [131]
transition on MINUSMINUS to state [162]
transition on for_update to state [378]
transition on IDENTIFIER to state [34]
transition on BOOLEAN_LITERAL to state [129]
transition on method_invocation to state [108]
transition on lparen_multiline to state [166]
transition on statement_expression to state [368]
transition on predecrement_expression to state [156]
transition on class_instance_creation_expression to state [119]
transition on UNDEFINED_LITERAL to state [128]
transition on postincrement_expression to state [163]
transition on field_access to state [123]
transition on left_hand_side to state [113]

-------------------
lalr_state [378]: {
  [for_update_opt ::= for_update (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [379]: {
  [terminator ::= (*) NEWLINE , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [for_statement ::= FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt (*) terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [for_statement_no_short_if ::= FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt (*) terminators statement_no_short_if , {ELSE }]
}
transition on NEWLINE to state [43]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [383]

-------------------
lalr_state [380]: {
  [comma_multiline ::= (*) COMMA terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_expression_list ::= statement_expression_list (*) comma_multiline statement_expression , {COMMA NEWLINE ENDOFFILE }]
  [for_update ::= statement_expression_list (*) , {NEWLINE ENDOFFILE }]
}
transition on comma_multiline to state [381]
transition on COMMA to state [36]

-------------------
lalr_state [381]: {
  [statement_expression ::= (*) method_invocation , {SEMICOLON COMMA NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {SEMICOLON COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_expression ::= (*) preincrement_expression , {SEMICOLON COMMA NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {SEMICOLON COMMA NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) class_instance_creation_expression , {SEMICOLON COMMA NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {SEMICOLON COMMA NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) predecrement_expression , {SEMICOLON COMMA NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postincrement_expression , {SEMICOLON COMMA NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {SEMICOLON COMMA NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postdecrement_expression , {SEMICOLON COMMA NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {SEMICOLON COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression_list ::= statement_expression_list comma_multiline (*) statement_expression , {SEMICOLON COMMA NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [statement_expression ::= (*) assignment , {SEMICOLON COMMA NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
}
transition on name to state [180]
transition on NULL_LITERAL to state [148]
transition on SUPER to state [134]
transition on array_access to state [112]
transition on NEW to state [167]
transition on literal to state [169]
transition on array_creation_expression to state [137]
transition on PLUSPLUS to state [165]
transition on qualified_name to state [35]
transition on primary to state [154]
transition on assignment to state [152]
transition on primary_no_new_array to state [164]
transition on NUMBER_LITERAL to state [127]
transition on postdecrement_expression to state [121]
transition on STRING_LITERAL to state [149]
transition on postfix_expression to state [122]
transition on THIS to state [150]
transition on LPAREN to state [89]
transition on preincrement_expression to state [131]
transition on MINUSMINUS to state [162]
transition on IDENTIFIER to state [34]
transition on BOOLEAN_LITERAL to state [129]
transition on method_invocation to state [108]
transition on lparen_multiline to state [166]
transition on statement_expression to state [382]
transition on predecrement_expression to state [156]
transition on UNDEFINED_LITERAL to state [128]
transition on class_instance_creation_expression to state [119]
transition on postincrement_expression to state [163]
transition on field_access to state [123]
transition on left_hand_side to state [113]

-------------------
lalr_state [382]: {
  [statement_expression_list ::= statement_expression_list comma_multiline statement_expression (*) , {SEMICOLON COMMA NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [383]: {
  [labeled_statement_no_short_if ::= (*) IDENTIFIER colon_multiline statement_no_short_if , {ELSE }]
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [if_then_statement ::= (*) IF expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_no_short_if ::= (*) statement_without_trailing_substatement , {ELSE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [throw_statement ::= (*) THROW expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) do_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [do_statement ::= (*) DO terminators_opt statement terminators_opt WHILE expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [expression_statement ::= (*) statement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_no_short_if ::= (*) labeled_statement_no_short_if , {ELSE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [try_statement ::= (*) TRY block terminators_opt catches , {ELSE WHILE NEWLINE ENDOFFILE }]
  [for_statement ::= FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators (*) statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) break_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) assignment , {ELSE WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [if_then_else_statement_no_short_if ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement_no_short_if , {ELSE }]
  [statement_no_short_if ::= (*) if_then_else_statement_no_short_if , {ELSE }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt catches terminators_opt finally , {ELSE WHILE NEWLINE ENDOFFILE }]
  [for_statement_no_short_if ::= FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators (*) statement_no_short_if , {ELSE }]
  [statement_without_trailing_substatement ::= (*) continue_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement_no_short_if ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement_no_short_if , {ELSE }]
  [statement_expression ::= (*) preincrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) statement_without_trailing_substatement , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [switch_statement ::= (*) SWITCH expression switch_block , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_no_short_if ::= (*) while_statement_no_short_if , {ELSE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt finally , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) return_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) predecrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) labeled_statement , {WHILE NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [statement_no_short_if ::= (*) for_statement_no_short_if , {ELSE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) throw_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postincrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_statement , {WHILE NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_without_trailing_substatement ::= (*) block , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) try_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postdecrement_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_else_statement , {WHILE NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [break_statement ::= (*) BREAK identifier_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) empty_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [empty_statement ::= (*) PASS , {ELSE WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT ELSE WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) method_invocation , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) while_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [continue_statement ::= (*) CONTINUE identifier_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) expression_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [while_statement ::= (*) WHILE expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [labeled_statement ::= (*) IDENTIFIER colon_multiline statement , {WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) class_instance_creation_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) for_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [return_statement ::= (*) RETURN expression_opt , {ELSE WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) switch_statement , {ELSE WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
  [while_statement_no_short_if ::= (*) WHILE expression terminators statement_no_short_if , {ELSE }]
}
transition on IDENTIFIER to state [353]
transition on DO to state [141]
transition on array_access to state [112]
transition on labeled_statement to state [157]
transition on if_then_else_statement to state [158]
transition on expression_statement to state [145]
transition on preincrement_expression to state [131]
transition on statement_without_trailing_substatement to state [352]
transition on try_statement to state [118]
transition on UNDEFINED_LITERAL to state [128]
transition on while_statement_no_short_if to state [351]
transition on WHILE to state [350]
transition on method_invocation to state [108]
transition on while_statement to state [153]
transition on LBRACE to state [47]
transition on primary_no_new_array to state [164]
transition on throw_statement to state [161]
transition on class_instance_creation_expression to state [119]
transition on SWITCH to state [140]
transition on postfix_expression to state [122]
transition on BREAK to state [146]
transition on return_statement to state [133]
transition on TRY to state [144]
transition on do_statement to state [170]
transition on continue_statement to state [155]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on postdecrement_expression to state [121]
transition on MINUSMINUS to state [162]
transition on RETURN to state [143]
transition on statement to state [385]
transition on qualified_name to state [35]
transition on for_statement_no_short_if to state [348]
transition on THIS to state [150]
transition on IF to state [347]
transition on NULL_LITERAL to state [148]
transition on primary to state [154]
transition on assignment to state [152]
transition on THROW to state [116]
transition on PASS to state [115]
transition on lparen_multiline to state [166]
transition on empty_statement to state [132]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on for_statement to state [107]
transition on lbrace_multiline to state [104]
transition on FOR to state [346]
transition on statement_no_short_if to state [384]
transition on block to state [120]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [156]
transition on LPAREN to state [89]
transition on CONTINUE to state [159]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [163]
transition on if_then_else_statement_no_short_if to state [344]
transition on switch_statement to state [111]
transition on break_statement to state [126]
transition on labeled_statement_no_short_if to state [343]
transition on left_hand_side to state [113]
transition on if_then_statement to state [135]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]
transition on statement_expression to state [117]

-------------------
lalr_state [384]: {
  [for_statement_no_short_if ::= FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement_no_short_if (*) , {ELSE }]
}

-------------------
lalr_state [385]: {
  [for_statement ::= FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement (*) , {WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [386]: {
  [semicolon_multiline ::= SEMICOLON terminators_opt (*) , {SEMICOLON LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [387]: {
  [terminator ::= (*) NEWLINE , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators ::= (*) terminator terminators , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [if_then_else_statement ::= IF expression terminators statement_no_short_if ELSE (*) terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [388]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [388]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [if_then_statement ::= (*) IF expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [throw_statement ::= (*) THROW expression , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) do_statement , {WHILE NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [do_statement ::= (*) DO terminators_opt statement terminators_opt WHILE expression , {WHILE NEWLINE ENDOFFILE }]
  [expression_statement ::= (*) statement_expression , {WHILE NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= IF expression terminators statement_no_short_if ELSE terminators_opt (*) statement , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [try_statement ::= (*) TRY block terminators_opt catches , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) break_statement , {WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) assignment , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt catches terminators_opt finally , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) continue_statement , {WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) preincrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) statement_without_trailing_substatement , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [switch_statement ::= (*) SWITCH expression switch_block , {WHILE NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {WHILE NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt finally , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) return_statement , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) predecrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) labeled_statement , {WHILE NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) throw_statement , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postincrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_statement , {WHILE NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_without_trailing_substatement ::= (*) block , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) try_statement , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postdecrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_else_statement , {WHILE NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [break_statement ::= (*) BREAK identifier_opt , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) empty_statement , {WHILE NEWLINE ENDOFFILE }]
  [empty_statement ::= (*) PASS , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) method_invocation , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) while_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [continue_statement ::= (*) CONTINUE identifier_opt , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) expression_statement , {WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [while_statement ::= (*) WHILE expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [labeled_statement ::= (*) IDENTIFIER colon_multiline statement , {WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) class_instance_creation_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) for_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [return_statement ::= (*) RETURN expression_opt , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) switch_statement , {WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
}
transition on IDENTIFIER to state [109]
transition on DO to state [141]
transition on array_access to state [112]
transition on labeled_statement to state [157]
transition on if_then_else_statement to state [158]
transition on expression_statement to state [145]
transition on preincrement_expression to state [131]
transition on statement_without_trailing_substatement to state [139]
transition on try_statement to state [118]
transition on UNDEFINED_LITERAL to state [128]
transition on WHILE to state [136]
transition on method_invocation to state [108]
transition on while_statement to state [153]
transition on LBRACE to state [47]
transition on primary_no_new_array to state [164]
transition on throw_statement to state [161]
transition on class_instance_creation_expression to state [119]
transition on SWITCH to state [140]
transition on postfix_expression to state [122]
transition on BREAK to state [146]
transition on return_statement to state [133]
transition on TRY to state [144]
transition on do_statement to state [170]
transition on continue_statement to state [155]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on postdecrement_expression to state [121]
transition on MINUSMINUS to state [162]
transition on RETURN to state [143]
transition on statement to state [367]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on IF to state [160]
transition on NULL_LITERAL to state [148]
transition on primary to state [154]
transition on assignment to state [152]
transition on THROW to state [116]
transition on PASS to state [115]
transition on lparen_multiline to state [166]
transition on empty_statement to state [132]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on for_statement to state [107]
transition on lbrace_multiline to state [104]
transition on FOR to state [142]
transition on block to state [120]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [156]
transition on LPAREN to state [89]
transition on CONTINUE to state [159]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [163]
transition on switch_statement to state [111]
transition on break_statement to state [126]
transition on left_hand_side to state [113]
transition on if_then_statement to state [135]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]
transition on statement_expression to state [117]

-------------------
lalr_state [389]: {
  [continue_statement ::= CONTINUE identifier_opt (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [390]: {
  [identifier_opt ::= IDENTIFIER (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [391]: {
  [field_access ::= primary DOT (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= primary DOT (*) IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [392]

-------------------
lalr_state [392]: {
  [method_invocation ::= primary DOT IDENTIFIER (*) lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN RPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= primary DOT IDENTIFIER (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on LPAREN to state [89]
transition on lparen_multiline to state [393]

-------------------
lalr_state [393]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {COMMA RPAREN ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {COMMA RPAREN OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list_opt ::= (*) , {RPAREN NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {COMMA RPAREN OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list_opt ::= (*) argument_list , {RPAREN NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {COMMA RPAREN AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= primary DOT IDENTIFIER lparen_multiline (*) argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list ::= (*) expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list ::= (*) argument_list comma_multiline expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {COMMA RPAREN XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {COMMA RPAREN OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on argument_list to state [192]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on expression to state [188]
transition on argument_list_opt to state [394]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [394]: {
  [terminator ::= (*) NEWLINE , {RPAREN NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RPAREN }]
  [method_invocation ::= primary DOT IDENTIFIER lparen_multiline argument_list_opt (*) rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RPAREN }]
  [rparen_multiline ::= (*) terminators_opt RPAREN , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {RPAREN }]
  [terminator ::= (*) ENDOFFILE , {RPAREN NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RPAREN }]
}
transition on NEWLINE to state [43]
transition on rparen_multiline to state [395]
transition on terminators_opt to state [98]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [395]: {
  [method_invocation ::= primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [396]: {
  [block ::= lbrace_multiline block_statements_opt rbrace_multiline (*) , {ELSE WHILE CATCH FINALLY NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [397]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {RBRACK NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {RBRACK LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {RBRACK EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {RBRACK NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {RBRACK ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {RBRACK }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {RBRACK LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {RBRACK EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK RBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {RBRACK ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RBRACK }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {RBRACK EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK RBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {RBRACK OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RBRACK }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {RBRACK AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK RBRACK DOT MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {RBRACK OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {RBRACK PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RBRACK }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [rbrack_multiline ::= (*) terminators_opt RBRACK , {LBRACK IDENTIFIER }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {RBRACK AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {RBRACK NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {RBRACK PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminator ::= (*) NEWLINE , {RBRACK NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {RBRACK XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {RBRACK NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {RBRACK PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {RBRACK NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {RBRACK MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {RBRACK XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {RBRACK NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {RBRACK LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {RBRACK OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [dims ::= lbrack_multiline (*) rbrack_multiline , {LBRACK IDENTIFIER }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {RBRACK NEWLINE ENDOFFILE }]
  [array_access ::= name lbrack_multiline (*) expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {RBRACK LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK RBRACK DOT MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {RBRACK LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {RBRACK OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {RBRACK MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK RBRACK DOT MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on rbrack_multiline to state [84]
transition on postfix_expression to state [193]
transition on terminators to state [39]
transition on conditional_expression to state [191]
transition on NEWLINE to state [43]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on postdecrement_expression to state [190]
transition on MINUSMINUS to state [162]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on expression to state [252]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on terminator to state [40]
transition on terminators_opt to state [81]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on ENDOFFILE to state [41]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [398]: {
  [break_statement ::= BREAK identifier_opt (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [399]: {
  [try_statement ::= TRY block (*) terminators_opt finally , {ELSE WHILE NEWLINE ENDOFFILE }]
  [terminator ::= (*) NEWLINE , {CATCH NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {CATCH FINALLY }]
  [try_statement ::= TRY block (*) terminators_opt catches terminators_opt finally , {ELSE WHILE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {CATCH FINALLY }]
  [terminators_opt ::= (*) , {CATCH FINALLY }]
  [try_statement ::= TRY block (*) terminators_opt catches , {ELSE WHILE NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {CATCH NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {CATCH FINALLY }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [400]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [400]: {
  [catches ::= (*) catches catch_clause , {ELSE WHILE CATCH FINALLY NEWLINE ENDOFFILE }]
  [try_statement ::= TRY block terminators_opt (*) catches , {ELSE WHILE NEWLINE ENDOFFILE }]
  [finally ::= (*) FINALLY terminators block , {ELSE WHILE NEWLINE ENDOFFILE }]
  [catches ::= (*) catch_clause , {ELSE WHILE CATCH FINALLY NEWLINE ENDOFFILE }]
  [try_statement ::= TRY block terminators_opt (*) finally , {ELSE WHILE NEWLINE ENDOFFILE }]
  [catch_clause ::= (*) CATCH formal_parameter terminators block , {ELSE WHILE CATCH FINALLY NEWLINE ENDOFFILE }]
  [try_statement ::= TRY block terminators_opt (*) catches terminators_opt finally , {ELSE WHILE NEWLINE ENDOFFILE }]
}
transition on CATCH to state [405]
transition on finally to state [404]
transition on catch_clause to state [403]
transition on FINALLY to state [402]
transition on catches to state [401]

-------------------
lalr_state [401]: {
  [catch_clause ::= (*) CATCH formal_parameter terminators block , {ELSE WHILE CATCH FINALLY NEWLINE ENDOFFILE }]
  [terminator ::= (*) NEWLINE , {FINALLY NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {FINALLY }]
  [try_statement ::= TRY block terminators_opt catches (*) terminators_opt finally , {ELSE WHILE NEWLINE ENDOFFILE }]
  [catches ::= catches (*) catch_clause , {ELSE WHILE CATCH FINALLY NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {FINALLY }]
  [terminators_opt ::= (*) , {FINALLY }]
  [try_statement ::= TRY block terminators_opt catches (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {FINALLY NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {FINALLY }]
}
transition on NEWLINE to state [43]
transition on CATCH to state [405]
transition on terminators_opt to state [412]
transition on ENDOFFILE to state [41]
transition on catch_clause to state [411]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [402]: {
  [terminator ::= (*) NEWLINE , {LBRACE NEWLINE ENDOFFILE }]
  [finally ::= FINALLY (*) terminators block , {ELSE WHILE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {LBRACE }]
  [terminator ::= (*) ENDOFFILE , {LBRACE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LBRACE }]
}
transition on NEWLINE to state [43]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [409]

-------------------
lalr_state [403]: {
  [catches ::= catch_clause (*) , {ELSE WHILE CATCH FINALLY NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [404]: {
  [try_statement ::= TRY block terminators_opt finally (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [405]: {
  [type ::= (*) primitive_type , {IDENTIFIER }]
  [primitive_type ::= (*) BOOLEAN , {LBRACK IDENTIFIER }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT IDENTIFIER }]
  [formal_parameter ::= (*) variable_declarator_id , {NEWLINE ENDOFFILE }]
  [primitive_type ::= (*) NUMBER , {LBRACK IDENTIFIER }]
  [reference_type ::= (*) array_type , {IDENTIFIER }]
  [variable_declarator_id ::= (*) IDENTIFIER , {NEWLINE ENDOFFILE }]
  [array_type ::= (*) name dims , {IDENTIFIER }]
  [type ::= (*) reference_type , {IDENTIFIER }]
  [primitive_type ::= (*) OBJECT , {LBRACK IDENTIFIER }]
  [name ::= (*) qualified_name , {LBRACK DOT IDENTIFIER }]
  [primitive_type ::= (*) STRING , {LBRACK IDENTIFIER }]
  [class_or_interface_type ::= (*) name , {IDENTIFIER }]
  [array_type ::= (*) ARRAY , {IDENTIFIER }]
  [formal_parameter ::= (*) type variable_declarator_id , {NEWLINE ENDOFFILE }]
  [catch_clause ::= CATCH (*) formal_parameter terminators block , {ELSE WHILE CATCH FINALLY NEWLINE ENDOFFILE }]
  [type ::= (*) VAR , {IDENTIFIER }]
  [reference_type ::= (*) class_or_interface_type , {IDENTIFIER }]
  [array_type ::= (*) primitive_type dims , {IDENTIFIER }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT IDENTIFIER }]
}
transition on array_type to state [72]
transition on IDENTIFIER to state [92]
transition on reference_type to state [68]
transition on type to state [91]
transition on primitive_type to state [71]
transition on formal_parameter to state [406]
transition on variable_declarator_id to state [95]
transition on qualified_name to state [35]
transition on VAR to state [74]
transition on STRING to state [67]
transition on class_or_interface_type to state [62]
transition on BOOLEAN to state [66]
transition on NUMBER to state [69]
transition on OBJECT to state [65]
transition on ARRAY to state [73]
transition on name to state [75]

-------------------
lalr_state [406]: {
  [terminator ::= (*) NEWLINE , {LBRACE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {LBRACE }]
  [catch_clause ::= CATCH formal_parameter (*) terminators block , {ELSE WHILE CATCH FINALLY NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {LBRACE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LBRACE }]
}
transition on NEWLINE to state [43]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [407]

-------------------
lalr_state [407]: {
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {ELSE WHILE CATCH FINALLY NEWLINE ENDOFFILE }]
  [catch_clause ::= CATCH formal_parameter terminators (*) block , {ELSE WHILE CATCH FINALLY NEWLINE ENDOFFILE }]
}
transition on block to state [408]
transition on lbrace_multiline to state [104]
transition on LBRACE to state [47]

-------------------
lalr_state [408]: {
  [catch_clause ::= CATCH formal_parameter terminators block (*) , {ELSE WHILE CATCH FINALLY NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [409]: {
  [finally ::= FINALLY terminators (*) block , {ELSE WHILE NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
}
transition on block to state [410]
transition on lbrace_multiline to state [104]
transition on LBRACE to state [47]

-------------------
lalr_state [410]: {
  [finally ::= FINALLY terminators block (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [411]: {
  [catches ::= catches catch_clause (*) , {ELSE WHILE CATCH FINALLY NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [412]: {
  [finally ::= (*) FINALLY terminators block , {ELSE WHILE NEWLINE ENDOFFILE }]
  [try_statement ::= TRY block terminators_opt catches terminators_opt (*) finally , {ELSE WHILE NEWLINE ENDOFFILE }]
}
transition on finally to state [413]
transition on FINALLY to state [402]

-------------------
lalr_state [413]: {
  [try_statement ::= TRY block terminators_opt catches terminators_opt finally (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [414]: {
  [return_statement ::= RETURN expression_opt (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [415]: {
  [semicolon_multiline ::= (*) SEMICOLON terminators_opt , {SEMICOLON LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [for_statement ::= FOR for_init_opt (*) semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
}
transition on semicolon_multiline to state [416]
transition on SEMICOLON to state [373]

-------------------
lalr_state [416]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {SEMICOLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT SEMICOLON MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [equality_expression ::= (*) relational_expression , {SEMICOLON EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) PLUS unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [expression ::= (*) assignment_expression , {SEMICOLON }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {SEMICOLON ANDAND OROR QUESTION }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT SEMICOLON MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary ::= (*) array_creation_expression , {DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {SEMICOLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) primary , {SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {SEMICOLON EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) MINUS unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT SEMICOLON MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {SEMICOLON ANDAND OROR QUESTION }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [for_statement ::= FOR for_init_opt semicolon_multiline (*) expression_opt semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT SEMICOLON MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {SEMICOLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) name , {SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {SEMICOLON EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [name ::= (*) qualified_name , {LBRACK DOT SEMICOLON MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [conditional_or_expression ::= (*) conditional_and_expression , {SEMICOLON OROR QUESTION }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT SEMICOLON MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {SEMICOLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) postincrement_expression , {SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [and_expression ::= (*) equality_expression , {SEMICOLON AND XOR OR ANDAND OROR QUESTION }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT SEMICOLON MULT EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {SEMICOLON OROR QUESTION }]
  [additive_expression ::= (*) multiplicative_expression , {SEMICOLON PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {SEMICOLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) postdecrement_expression , {SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {SEMICOLON AND XOR OR ANDAND OROR QUESTION }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [conditional_expression ::= (*) conditional_or_expression , {SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {SEMICOLON PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {SEMICOLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {SEMICOLON XOR OR ANDAND OROR QUESTION }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {SEMICOLON PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {SEMICOLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {SEMICOLON XOR OR ANDAND OROR QUESTION }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [assignment_expression ::= (*) conditional_expression , {SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {SEMICOLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {SEMICOLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) preincrement_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [expression_opt ::= (*) , {SEMICOLON }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {SEMICOLON OR ANDAND OROR QUESTION }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [assignment_expression ::= (*) assignment , {SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {SEMICOLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT SEMICOLON MULT EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {SEMICOLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) predecrement_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [expression_opt ::= (*) expression , {SEMICOLON }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {SEMICOLON OR ANDAND OROR QUESTION }]
  [multiplicative_expression ::= (*) unary_expression , {SEMICOLON MULT PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary ::= (*) primary_no_new_array , {DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT SEMICOLON MULT PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on expression_opt to state [417]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on expression to state [375]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [417]: {
  [semicolon_multiline ::= (*) SEMICOLON terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [for_statement ::= FOR for_init_opt semicolon_multiline expression_opt (*) semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
}
transition on semicolon_multiline to state [418]
transition on SEMICOLON to state [373]

-------------------
lalr_state [418]: {
  [statement_expression ::= (*) method_invocation , {COMMA NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_expression ::= (*) preincrement_expression , {COMMA NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {COMMA NEWLINE ENDOFFILE }]
  [for_update_opt ::= (*) for_update , {NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) class_instance_creation_expression , {COMMA NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {COMMA NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) predecrement_expression , {COMMA NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [for_update ::= (*) statement_expression_list , {NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postincrement_expression , {COMMA NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {COMMA NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [for_statement ::= FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline (*) for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [statement_expression_list ::= (*) statement_expression , {COMMA NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postdecrement_expression , {COMMA NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT COMMA PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [statement_expression_list ::= (*) statement_expression_list comma_multiline statement_expression , {COMMA NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) assignment , {COMMA NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
  [for_update_opt ::= (*) , {NEWLINE ENDOFFILE }]
}
transition on name to state [180]
transition on NULL_LITERAL to state [148]
transition on SUPER to state [134]
transition on array_access to state [112]
transition on NEW to state [167]
transition on literal to state [169]
transition on statement_expression_list to state [380]
transition on array_creation_expression to state [137]
transition on PLUSPLUS to state [165]
transition on qualified_name to state [35]
transition on primary to state [154]
transition on assignment to state [152]
transition on primary_no_new_array to state [164]
transition on NUMBER_LITERAL to state [127]
transition on postdecrement_expression to state [121]
transition on for_update_opt to state [419]
transition on STRING_LITERAL to state [149]
transition on postfix_expression to state [122]
transition on THIS to state [150]
transition on LPAREN to state [89]
transition on preincrement_expression to state [131]
transition on MINUSMINUS to state [162]
transition on for_update to state [378]
transition on IDENTIFIER to state [34]
transition on BOOLEAN_LITERAL to state [129]
transition on method_invocation to state [108]
transition on lparen_multiline to state [166]
transition on statement_expression to state [368]
transition on predecrement_expression to state [156]
transition on class_instance_creation_expression to state [119]
transition on UNDEFINED_LITERAL to state [128]
transition on postincrement_expression to state [163]
transition on field_access to state [123]
transition on left_hand_side to state [113]

-------------------
lalr_state [419]: {
  [terminator ::= (*) NEWLINE , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [for_statement ::= FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt (*) terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [420]

-------------------
lalr_state [420]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [if_then_statement ::= (*) IF expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [throw_statement ::= (*) THROW expression , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) do_statement , {WHILE NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [do_statement ::= (*) DO terminators_opt statement terminators_opt WHILE expression , {WHILE NEWLINE ENDOFFILE }]
  [expression_statement ::= (*) statement_expression , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [try_statement ::= (*) TRY block terminators_opt catches , {WHILE NEWLINE ENDOFFILE }]
  [for_statement ::= FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators (*) statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) break_statement , {WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) assignment , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt catches terminators_opt finally , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) continue_statement , {WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) preincrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) statement_without_trailing_substatement , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [switch_statement ::= (*) SWITCH expression switch_block , {WHILE NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {WHILE NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt finally , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) return_statement , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) predecrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) labeled_statement , {WHILE NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) throw_statement , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postincrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_statement , {WHILE NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_without_trailing_substatement ::= (*) block , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) try_statement , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postdecrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_else_statement , {WHILE NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [break_statement ::= (*) BREAK identifier_opt , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) empty_statement , {WHILE NEWLINE ENDOFFILE }]
  [empty_statement ::= (*) PASS , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) method_invocation , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) while_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [continue_statement ::= (*) CONTINUE identifier_opt , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) expression_statement , {WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [while_statement ::= (*) WHILE expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [labeled_statement ::= (*) IDENTIFIER colon_multiline statement , {WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) class_instance_creation_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) for_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [return_statement ::= (*) RETURN expression_opt , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) switch_statement , {WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
}
transition on IDENTIFIER to state [109]
transition on DO to state [141]
transition on array_access to state [112]
transition on labeled_statement to state [157]
transition on if_then_else_statement to state [158]
transition on expression_statement to state [145]
transition on preincrement_expression to state [131]
transition on statement_without_trailing_substatement to state [139]
transition on try_statement to state [118]
transition on UNDEFINED_LITERAL to state [128]
transition on WHILE to state [136]
transition on method_invocation to state [108]
transition on while_statement to state [153]
transition on LBRACE to state [47]
transition on primary_no_new_array to state [164]
transition on throw_statement to state [161]
transition on class_instance_creation_expression to state [119]
transition on SWITCH to state [140]
transition on postfix_expression to state [122]
transition on BREAK to state [146]
transition on return_statement to state [133]
transition on TRY to state [144]
transition on do_statement to state [170]
transition on continue_statement to state [155]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on postdecrement_expression to state [121]
transition on MINUSMINUS to state [162]
transition on RETURN to state [143]
transition on statement to state [385]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on IF to state [160]
transition on NULL_LITERAL to state [148]
transition on primary to state [154]
transition on assignment to state [152]
transition on THROW to state [116]
transition on PASS to state [115]
transition on lparen_multiline to state [166]
transition on empty_statement to state [132]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on for_statement to state [107]
transition on lbrace_multiline to state [104]
transition on FOR to state [142]
transition on block to state [120]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [156]
transition on LPAREN to state [89]
transition on CONTINUE to state [159]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [163]
transition on switch_statement to state [111]
transition on break_statement to state [126]
transition on left_hand_side to state [113]
transition on if_then_statement to state [135]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]
transition on statement_expression to state [117]

-------------------
lalr_state [421]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [if_then_statement ::= (*) IF expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [throw_statement ::= (*) THROW expression , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) do_statement , {WHILE NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [do_statement ::= DO terminators_opt (*) statement terminators_opt WHILE expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [do_statement ::= (*) DO terminators_opt statement terminators_opt WHILE expression , {WHILE NEWLINE ENDOFFILE }]
  [expression_statement ::= (*) statement_expression , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [try_statement ::= (*) TRY block terminators_opt catches , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) break_statement , {WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) assignment , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt catches terminators_opt finally , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) continue_statement , {WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) preincrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) statement_without_trailing_substatement , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [switch_statement ::= (*) SWITCH expression switch_block , {WHILE NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {WHILE NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt finally , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) return_statement , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) predecrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) labeled_statement , {WHILE NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) throw_statement , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postincrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_statement , {WHILE NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_without_trailing_substatement ::= (*) block , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) try_statement , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postdecrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_else_statement , {WHILE NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [break_statement ::= (*) BREAK identifier_opt , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) empty_statement , {WHILE NEWLINE ENDOFFILE }]
  [empty_statement ::= (*) PASS , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) method_invocation , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) while_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [continue_statement ::= (*) CONTINUE identifier_opt , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) expression_statement , {WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [while_statement ::= (*) WHILE expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [labeled_statement ::= (*) IDENTIFIER colon_multiline statement , {WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) class_instance_creation_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) for_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [return_statement ::= (*) RETURN expression_opt , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) switch_statement , {WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
}
transition on IDENTIFIER to state [109]
transition on DO to state [141]
transition on array_access to state [112]
transition on labeled_statement to state [157]
transition on if_then_else_statement to state [158]
transition on expression_statement to state [145]
transition on preincrement_expression to state [131]
transition on statement_without_trailing_substatement to state [139]
transition on try_statement to state [118]
transition on UNDEFINED_LITERAL to state [128]
transition on WHILE to state [136]
transition on method_invocation to state [108]
transition on while_statement to state [153]
transition on LBRACE to state [47]
transition on primary_no_new_array to state [164]
transition on throw_statement to state [161]
transition on class_instance_creation_expression to state [119]
transition on SWITCH to state [140]
transition on postfix_expression to state [122]
transition on BREAK to state [146]
transition on return_statement to state [133]
transition on TRY to state [144]
transition on do_statement to state [170]
transition on continue_statement to state [155]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on postdecrement_expression to state [121]
transition on MINUSMINUS to state [162]
transition on RETURN to state [143]
transition on statement to state [422]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on IF to state [160]
transition on NULL_LITERAL to state [148]
transition on primary to state [154]
transition on assignment to state [152]
transition on THROW to state [116]
transition on PASS to state [115]
transition on lparen_multiline to state [166]
transition on empty_statement to state [132]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on for_statement to state [107]
transition on lbrace_multiline to state [104]
transition on FOR to state [142]
transition on block to state [120]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [156]
transition on LPAREN to state [89]
transition on CONTINUE to state [159]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [163]
transition on switch_statement to state [111]
transition on break_statement to state [126]
transition on left_hand_side to state [113]
transition on if_then_statement to state [135]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]
transition on statement_expression to state [117]

-------------------
lalr_state [422]: {
  [terminator ::= (*) NEWLINE , {WHILE NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {WHILE }]
  [terminators ::= (*) terminator terminators , {WHILE }]
  [terminators_opt ::= (*) , {WHILE }]
  [terminator ::= (*) ENDOFFILE , {WHILE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {WHILE }]
  [do_statement ::= DO terminators_opt statement (*) terminators_opt WHILE expression , {ELSE WHILE NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [423]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [423]: {
  [do_statement ::= DO terminators_opt statement terminators_opt (*) WHILE expression , {ELSE WHILE NEWLINE ENDOFFILE }]
}
transition on WHILE to state [424]

-------------------
lalr_state [424]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT EQ ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [do_statement ::= DO terminators_opt statement terminators_opt WHILE (*) expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {ELSE WHILE ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT EQ ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT EQ LPAREN ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {ELSE WHILE ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT EQ ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT EQ LPAREN ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {ELSE WHILE OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT EQ ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {ELSE WHILE AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT EQ LPAREN ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {ELSE WHILE OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {ELSE WHILE AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {ELSE WHILE XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {ELSE WHILE XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {ELSE WHILE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {ELSE WHILE OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {ELSE WHILE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT EQ ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {ELSE WHILE OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on expression to state [425]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [425]: {
  [do_statement ::= DO terminators_opt statement terminators_opt WHILE expression (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [426]: {
  [switch_block ::= (*) lbrace_multiline rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
  [switch_block ::= (*) lbrace_multiline switch_block_statement_groups switch_labels rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [switch_statement ::= SWITCH expression (*) switch_block , {ELSE WHILE NEWLINE ENDOFFILE }]
  [switch_block ::= (*) lbrace_multiline switch_labels rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
  [switch_block ::= (*) lbrace_multiline switch_block_statement_groups rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
}
transition on lbrace_multiline to state [428]
transition on switch_block to state [427]
transition on LBRACE to state [47]

-------------------
lalr_state [427]: {
  [switch_statement ::= SWITCH expression switch_block (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [428]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {COMMA RBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {COMMA RBRACE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [switch_block_statement_groups ::= (*) switch_block_statement_groups switch_block_statement_group , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {COMMA RBRACE ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {RBRACE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {COMMA RBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {COMMA RBRACE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [switch_block_statement_group ::= (*) switch_case_header block_statement terminators block_statements , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [constant_expression ::= (*) expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {COMMA RBRACE ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RBRACE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [rbrace_multiline ::= (*) terminators_opt RBRACE , {ELSE WHILE NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {COMMA RBRACE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT COMMA RBRACE EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [switch_case_header ::= (*) CASE switch_labels colon_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [conditional_or_expression ::= (*) conditional_and_expression , {COMMA RBRACE OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RBRACE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {COMMA RBRACE AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [switch_case_header ::= (*) DEFAULT colon_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {COMMA RBRACE OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RBRACE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RBRACE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [switch_block ::= lbrace_multiline (*) switch_block_statement_groups switch_labels rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {COMMA RBRACE AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [switch_labels ::= (*) switch_label , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {COMMA RBRACE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminator ::= (*) NEWLINE , {RBRACE NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [switch_block ::= lbrace_multiline (*) switch_block_statement_groups rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RBRACE XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [switch_labels ::= (*) switch_labels comma_multiline switch_label , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {COMMA RBRACE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {RBRACE NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [switch_block ::= lbrace_multiline (*) switch_labels rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {COMMA RBRACE XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [switch_label ::= (*) constant_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {COMMA RBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [switch_block ::= lbrace_multiline (*) rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RBRACE OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {COMMA RBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [switch_block_statement_groups ::= (*) switch_block_statement_group , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {COMMA RBRACE OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on switch_label to state [438]
transition on switch_case_header to state [437]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on DEFAULT to state [436]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on switch_block_statement_group to state [435]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on terminators to state [39]
transition on conditional_expression to state [191]
transition on NEWLINE to state [43]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on postdecrement_expression to state [190]
transition on MINUSMINUS to state [162]
transition on unary_expression to state [189]
transition on expression to state [434]
transition on qualified_name to state [35]
transition on switch_labels to state [433]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on terminator to state [40]
transition on terminators_opt to state [312]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on constant_expression to state [432]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on CASE to state [431]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on switch_block_statement_groups to state [430]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on ENDOFFILE to state [41]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]
transition on rbrace_multiline to state [429]

-------------------
lalr_state [429]: {
  [switch_block ::= lbrace_multiline rbrace_multiline (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [430]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {COMMA RBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {COMMA RBRACE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [switch_block_statement_groups ::= switch_block_statement_groups (*) switch_block_statement_group , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {COMMA RBRACE ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {RBRACE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {COMMA RBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {COMMA RBRACE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [switch_block_statement_group ::= (*) switch_case_header block_statement terminators block_statements , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [constant_expression ::= (*) expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {COMMA RBRACE ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RBRACE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [rbrace_multiline ::= (*) terminators_opt RBRACE , {ELSE WHILE NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {COMMA RBRACE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT COMMA RBRACE EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [switch_case_header ::= (*) CASE switch_labels colon_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [conditional_or_expression ::= (*) conditional_and_expression , {COMMA RBRACE OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RBRACE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {COMMA RBRACE AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ LPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [switch_case_header ::= (*) DEFAULT colon_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {COMMA RBRACE OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RBRACE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RBRACE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [switch_block ::= lbrace_multiline switch_block_statement_groups (*) switch_labels rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {COMMA RBRACE AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [switch_labels ::= (*) switch_label , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {COMMA RBRACE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminator ::= (*) NEWLINE , {RBRACE NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [switch_block ::= lbrace_multiline switch_block_statement_groups (*) rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RBRACE XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [switch_labels ::= (*) switch_labels comma_multiline switch_label , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {COMMA RBRACE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {RBRACE NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {COMMA RBRACE XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [switch_label ::= (*) constant_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {COMMA RBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RBRACE OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {COMMA RBRACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA RBRACE EQ PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {COMMA RBRACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {COMMA RBRACE OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT COMMA RBRACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT COMMA RBRACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on switch_label to state [438]
transition on switch_case_header to state [437]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on DEFAULT to state [436]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on switch_block_statement_group to state [450]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on terminators to state [39]
transition on conditional_expression to state [191]
transition on NEWLINE to state [43]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on postdecrement_expression to state [190]
transition on MINUSMINUS to state [162]
transition on unary_expression to state [189]
transition on expression to state [434]
transition on qualified_name to state [35]
transition on switch_labels to state [449]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on terminator to state [40]
transition on terminators_opt to state [312]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on constant_expression to state [432]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on CASE to state [431]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on ENDOFFILE to state [41]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]
transition on rbrace_multiline to state [448]

-------------------
lalr_state [431]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {COMMA COLON }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {COMMA COLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA EQ COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [equality_expression ::= (*) relational_expression , {COMMA COLON EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT COMMA COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [expression ::= (*) assignment_expression , {COMMA COLON }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {COMMA COLON ANDAND OROR QUESTION }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT COMMA COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary ::= (*) array_creation_expression , {DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {COMMA COLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) primary , {MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {COMMA COLON EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT COMMA COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT COMMA EQ LPAREN COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [constant_expression ::= (*) expression , {COMMA COLON }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {COMMA COLON ANDAND OROR QUESTION }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT COMMA COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {COMMA COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) name , {MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {COMMA COLON EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT COMMA COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT COMMA EQ LPAREN COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [switch_case_header ::= CASE (*) switch_labels colon_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [conditional_or_expression ::= (*) conditional_and_expression , {COMMA COLON OROR QUESTION }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT COMMA COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {COMMA COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) postincrement_expression , {MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [and_expression ::= (*) equality_expression , {COMMA COLON AND XOR OR ANDAND OROR QUESTION }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT COMMA COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ LPAREN COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {COMMA COLON OROR QUESTION }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA COLON PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {COMMA COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {COMMA COLON AND XOR OR ANDAND OROR QUESTION }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT COMMA COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [switch_labels ::= (*) switch_label , {COMMA COLON }]
  [conditional_expression ::= (*) conditional_or_expression , {COMMA COLON }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {COMMA COLON PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {COMMA COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA COLON XOR OR ANDAND OROR QUESTION }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT COMMA COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [switch_labels ::= (*) switch_labels comma_multiline switch_label , {COMMA COLON }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {COMMA COLON }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {COMMA COLON PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {COMMA COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {COMMA COLON XOR OR ANDAND OROR QUESTION }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT COMMA COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [switch_label ::= (*) constant_expression , {COMMA COLON }]
  [assignment_expression ::= (*) conditional_expression , {COMMA COLON }]
  [shift_expression ::= (*) additive_expression , {COMMA COLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {COMMA COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) preincrement_expression , {MULT COMMA COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA COLON OR ANDAND OROR QUESTION }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT COMMA COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [assignment_expression ::= (*) assignment , {COMMA COLON }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {COMMA COLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA EQ COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {COMMA COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [unary_expression ::= (*) predecrement_expression , {MULT COMMA COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {COMMA COLON OR ANDAND OROR QUESTION }]
  [multiplicative_expression ::= (*) unary_expression , {MULT COMMA COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [primary ::= (*) primary_no_new_array , {DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT COMMA COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION }]
}
transition on IDENTIFIER to state [34]
transition on switch_label to state [438]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on expression to state [434]
transition on qualified_name to state [35]
transition on switch_labels to state [446]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on constant_expression to state [432]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [432]: {
  [switch_label ::= constant_expression (*) , {COMMA RBRACE COLON NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [433]: {
  [rbrace_multiline ::= (*) terminators_opt RBRACE , {ELSE WHILE NEWLINE ENDOFFILE }]
  [comma_multiline ::= (*) COMMA terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) NEWLINE , {RBRACE NEWLINE ENDOFFILE }]
  [switch_block ::= lbrace_multiline switch_labels (*) rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RBRACE }]
  [switch_labels ::= switch_labels (*) comma_multiline switch_label , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RBRACE }]
  [terminators_opt ::= (*) , {RBRACE }]
  [terminator ::= (*) ENDOFFILE , {RBRACE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RBRACE }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [312]
transition on rbrace_multiline to state [444]
transition on comma_multiline to state [443]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]
transition on COMMA to state [36]

-------------------
lalr_state [434]: {
  [constant_expression ::= expression (*) , {COMMA RBRACE COLON NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [435]: {
  [switch_block_statement_groups ::= switch_block_statement_group (*) , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [436]: {
  [switch_case_header ::= DEFAULT (*) colon_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [colon_multiline ::= (*) COLON terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on colon_multiline to state [442]
transition on COLON to state [290]

-------------------
lalr_state [437]: {
  [block_statement ::= (*) interface_declaration , {NEWLINE ENDOFFILE }]
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [modifier ::= (*) PROTECTED , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [primitive_type ::= (*) BOOLEAN , {LBRACK IDENTIFIER }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [if_then_statement ::= (*) IF expression terminators statement , {NEWLINE ENDOFFILE }]
  [array_type ::= (*) ARRAY , {IDENTIFIER }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [throw_statement ::= (*) THROW expression , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) do_statement , {NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [do_statement ::= (*) DO terminators_opt statement terminators_opt WHILE expression , {NEWLINE ENDOFFILE }]
  [expression_statement ::= (*) statement_expression , {NEWLINE ENDOFFILE }]
  [local_variable_declaration_statement ::= (*) local_variable_declaration , {NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [modifier ::= (*) PRIVATE , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [primitive_type ::= (*) OBJECT , {LBRACK IDENTIFIER }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement , {NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [switch_block_statement_group ::= switch_case_header (*) block_statement terminators block_statements , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [try_statement ::= (*) TRY block terminators_opt catches , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) break_statement , {NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) assignment , {NEWLINE ENDOFFILE }]
  [local_variable_declaration ::= (*) type variable_declarators , {NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [modifier ::= (*) STATIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [reference_type ::= (*) class_or_interface_type , {IDENTIFIER }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [try_statement ::= (*) TRY block terminators_opt catches terminators_opt finally , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) continue_statement , {NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) preincrement_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) statement_without_trailing_substatement , {NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [modifier ::= (*) ABSTRACT , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [reference_type ::= (*) array_type , {IDENTIFIER }]
  [switch_statement ::= (*) SWITCH expression switch_block , {NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [try_statement ::= (*) TRY block terminators_opt finally , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) return_statement , {NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [modifiers_opt ::= (*) , {CLASS INTERFACE }]
  [type ::= (*) primitive_type , {IDENTIFIER }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) predecrement_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) labeled_statement , {NEWLINE ENDOFFILE }]
  [class_declaration ::= (*) modifiers_opt CLASS IDENTIFIER super_opt interfaces_opt class_body , {NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [class_or_interface_type ::= (*) name , {IDENTIFIER }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) throw_statement , {NEWLINE ENDOFFILE }]
  [interface_declaration ::= (*) modifiers_opt INTERFACE IDENTIFIER extends_interfaces_opt interface_body , {NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [modifiers_opt ::= (*) modifiers , {CLASS INTERFACE }]
  [type ::= (*) reference_type , {IDENTIFIER }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postincrement_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_statement , {NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_without_trailing_substatement ::= (*) block , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) try_statement , {NEWLINE ENDOFFILE }]
  [block_statement ::= (*) local_variable_declaration_statement , {NEWLINE ENDOFFILE }]
  [modifiers ::= (*) modifier , {CLASS INTERFACE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [type ::= (*) VAR , {IDENTIFIER }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postdecrement_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_else_statement , {NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [break_statement ::= (*) BREAK identifier_opt , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) empty_statement , {NEWLINE ENDOFFILE }]
  [empty_statement ::= (*) PASS , {NEWLINE ENDOFFILE }]
  [block_statement ::= (*) statement , {NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [modifiers ::= (*) modifier modifiers , {CLASS INTERFACE }]
  [primitive_type ::= (*) NUMBER , {LBRACK IDENTIFIER }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) method_invocation , {NEWLINE ENDOFFILE }]
  [statement ::= (*) while_statement , {NEWLINE ENDOFFILE }]
  [array_type ::= (*) primitive_type dims , {IDENTIFIER }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [continue_statement ::= (*) CONTINUE identifier_opt , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) expression_statement , {NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [while_statement ::= (*) WHILE expression terminators statement , {NEWLINE ENDOFFILE }]
  [labeled_statement ::= (*) IDENTIFIER colon_multiline statement , {NEWLINE ENDOFFILE }]
  [block_statement ::= (*) class_declaration , {NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [modifier ::= (*) PUBLIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [primitive_type ::= (*) STRING , {LBRACK IDENTIFIER }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) class_instance_creation_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) for_statement , {NEWLINE ENDOFFILE }]
  [array_type ::= (*) name dims , {IDENTIFIER }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [return_statement ::= (*) RETURN expression_opt , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) switch_statement , {NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
}
transition on do_statement to state [170]
transition on STATIC to state [11]
transition on PRIVATE to state [15]
transition on literal to state [169]
transition on statement to state [168]
transition on STRING to state [67]
transition on NEW to state [167]
transition on lparen_multiline to state [166]
transition on PLUSPLUS to state [165]
transition on qualified_name to state [35]
transition on primary_no_new_array to state [164]
transition on postincrement_expression to state [163]
transition on MINUSMINUS to state [162]
transition on throw_statement to state [161]
transition on IF to state [160]
transition on CONTINUE to state [159]
transition on if_then_else_statement to state [158]
transition on labeled_statement to state [157]
transition on predecrement_expression to state [156]
transition on continue_statement to state [155]
transition on modifiers_opt to state [20]
transition on primary to state [154]
transition on while_statement to state [153]
transition on assignment to state [152]
transition on primitive_type to state [71]
transition on lbrace_multiline to state [104]
transition on THIS to state [150]
transition on STRING_LITERAL to state [149]
transition on modifiers to state [17]
transition on NULL_LITERAL to state [148]
transition on name to state [147]
transition on BREAK to state [146]
transition on expression_statement to state [145]
transition on TRY to state [144]
transition on PUBLIC to state [10]
transition on RETURN to state [143]
transition on FOR to state [142]
transition on DO to state [141]
transition on SWITCH to state [140]
transition on statement_without_trailing_substatement to state [139]
transition on type to state [138]
transition on BOOLEAN to state [66]
transition on array_creation_expression to state [137]
transition on reference_type to state [68]
transition on WHILE to state [136]
transition on if_then_statement to state [135]
transition on ABSTRACT to state [8]
transition on SUPER to state [134]
transition on return_statement to state [133]
transition on empty_statement to state [132]
transition on NUMBER to state [69]
transition on preincrement_expression to state [131]
transition on local_variable_declaration to state [130]
transition on BOOLEAN_LITERAL to state [129]
transition on UNDEFINED_LITERAL to state [128]
transition on NUMBER_LITERAL to state [127]
transition on break_statement to state [126]
transition on local_variable_declaration_statement to state [125]
transition on VAR to state [74]
transition on OBJECT to state [65]
transition on ARRAY to state [73]
transition on interface_declaration to state [124]
transition on modifier to state [12]
transition on PROTECTED to state [13]
transition on field_access to state [123]
transition on postfix_expression to state [122]
transition on LPAREN to state [89]
transition on LBRACE to state [47]
transition on postdecrement_expression to state [121]
transition on block to state [120]
transition on class_instance_creation_expression to state [119]
transition on try_statement to state [118]
transition on statement_expression to state [117]
transition on THROW to state [116]
transition on PASS to state [115]
transition on array_type to state [72]
transition on class_declaration to state [114]
transition on left_hand_side to state [113]
transition on array_access to state [112]
transition on switch_statement to state [111]
transition on block_statement to state [439]
transition on class_or_interface_type to state [62]
transition on IDENTIFIER to state [109]
transition on method_invocation to state [108]
transition on for_statement to state [107]

-------------------
lalr_state [438]: {
  [switch_labels ::= switch_label (*) , {COMMA RBRACE COLON NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [439]: {
  [terminator ::= (*) NEWLINE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [switch_block_statement_group ::= switch_case_header block_statement (*) terminators block_statements , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [440]

-------------------
lalr_state [440]: {
  [block_statement ::= (*) interface_declaration , {NEWLINE ENDOFFILE }]
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [modifier ::= (*) PROTECTED , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [primitive_type ::= (*) BOOLEAN , {LBRACK IDENTIFIER }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [if_then_statement ::= (*) IF expression terminators statement , {NEWLINE ENDOFFILE }]
  [array_type ::= (*) ARRAY , {IDENTIFIER }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [throw_statement ::= (*) THROW expression , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) do_statement , {NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [do_statement ::= (*) DO terminators_opt statement terminators_opt WHILE expression , {NEWLINE ENDOFFILE }]
  [expression_statement ::= (*) statement_expression , {NEWLINE ENDOFFILE }]
  [local_variable_declaration_statement ::= (*) local_variable_declaration , {NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [modifier ::= (*) PRIVATE , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [primitive_type ::= (*) OBJECT , {LBRACK IDENTIFIER }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement , {NEWLINE ENDOFFILE }]
  [switch_block_statement_group ::= switch_case_header block_statement terminators (*) block_statements , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [try_statement ::= (*) TRY block terminators_opt catches , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) break_statement , {NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) assignment , {NEWLINE ENDOFFILE }]
  [local_variable_declaration ::= (*) type variable_declarators , {NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [modifier ::= (*) STATIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [reference_type ::= (*) class_or_interface_type , {IDENTIFIER }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [try_statement ::= (*) TRY block terminators_opt catches terminators_opt finally , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) continue_statement , {NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) preincrement_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) statement_without_trailing_substatement , {NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [modifier ::= (*) ABSTRACT , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [reference_type ::= (*) array_type , {IDENTIFIER }]
  [switch_statement ::= (*) SWITCH expression switch_block , {NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [try_statement ::= (*) TRY block terminators_opt finally , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) return_statement , {NEWLINE ENDOFFILE }]
  [block_statements ::= (*) block_statement terminators , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [modifiers_opt ::= (*) , {CLASS INTERFACE }]
  [type ::= (*) primitive_type , {IDENTIFIER }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) predecrement_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) labeled_statement , {NEWLINE ENDOFFILE }]
  [class_declaration ::= (*) modifiers_opt CLASS IDENTIFIER super_opt interfaces_opt class_body , {NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [class_or_interface_type ::= (*) name , {IDENTIFIER }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) throw_statement , {NEWLINE ENDOFFILE }]
  [block_statements ::= (*) block_statement terminators block_statements , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [interface_declaration ::= (*) modifiers_opt INTERFACE IDENTIFIER extends_interfaces_opt interface_body , {NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [modifiers_opt ::= (*) modifiers , {CLASS INTERFACE }]
  [type ::= (*) reference_type , {IDENTIFIER }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postincrement_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_statement , {NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_without_trailing_substatement ::= (*) block , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) try_statement , {NEWLINE ENDOFFILE }]
  [block_statement ::= (*) local_variable_declaration_statement , {NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [modifiers ::= (*) modifier , {CLASS INTERFACE }]
  [type ::= (*) VAR , {IDENTIFIER }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postdecrement_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_else_statement , {NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [break_statement ::= (*) BREAK identifier_opt , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) empty_statement , {NEWLINE ENDOFFILE }]
  [empty_statement ::= (*) PASS , {NEWLINE ENDOFFILE }]
  [block_statement ::= (*) statement , {NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [modifiers ::= (*) modifier modifiers , {CLASS INTERFACE }]
  [primitive_type ::= (*) NUMBER , {LBRACK IDENTIFIER }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) method_invocation , {NEWLINE ENDOFFILE }]
  [statement ::= (*) while_statement , {NEWLINE ENDOFFILE }]
  [array_type ::= (*) primitive_type dims , {IDENTIFIER }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [continue_statement ::= (*) CONTINUE identifier_opt , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) expression_statement , {NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [while_statement ::= (*) WHILE expression terminators statement , {NEWLINE ENDOFFILE }]
  [labeled_statement ::= (*) IDENTIFIER colon_multiline statement , {NEWLINE ENDOFFILE }]
  [block_statement ::= (*) class_declaration , {NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [modifier ::= (*) PUBLIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [primitive_type ::= (*) STRING , {LBRACK IDENTIFIER }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) class_instance_creation_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) for_statement , {NEWLINE ENDOFFILE }]
  [array_type ::= (*) name dims , {IDENTIFIER }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [return_statement ::= (*) RETURN expression_opt , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) switch_statement , {NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
}
transition on do_statement to state [170]
transition on STATIC to state [11]
transition on PRIVATE to state [15]
transition on literal to state [169]
transition on statement to state [168]
transition on STRING to state [67]
transition on NEW to state [167]
transition on lparen_multiline to state [166]
transition on PLUSPLUS to state [165]
transition on qualified_name to state [35]
transition on primary_no_new_array to state [164]
transition on postincrement_expression to state [163]
transition on MINUSMINUS to state [162]
transition on throw_statement to state [161]
transition on IF to state [160]
transition on CONTINUE to state [159]
transition on if_then_else_statement to state [158]
transition on labeled_statement to state [157]
transition on predecrement_expression to state [156]
transition on continue_statement to state [155]
transition on modifiers_opt to state [20]
transition on primary to state [154]
transition on while_statement to state [153]
transition on assignment to state [152]
transition on primitive_type to state [71]
transition on lbrace_multiline to state [104]
transition on THIS to state [150]
transition on STRING_LITERAL to state [149]
transition on modifiers to state [17]
transition on NULL_LITERAL to state [148]
transition on name to state [147]
transition on BREAK to state [146]
transition on expression_statement to state [145]
transition on TRY to state [144]
transition on PUBLIC to state [10]
transition on RETURN to state [143]
transition on FOR to state [142]
transition on DO to state [141]
transition on SWITCH to state [140]
transition on statement_without_trailing_substatement to state [139]
transition on type to state [138]
transition on BOOLEAN to state [66]
transition on array_creation_expression to state [137]
transition on reference_type to state [68]
transition on WHILE to state [136]
transition on if_then_statement to state [135]
transition on ABSTRACT to state [8]
transition on SUPER to state [134]
transition on return_statement to state [133]
transition on empty_statement to state [132]
transition on NUMBER to state [69]
transition on preincrement_expression to state [131]
transition on local_variable_declaration to state [130]
transition on BOOLEAN_LITERAL to state [129]
transition on UNDEFINED_LITERAL to state [128]
transition on NUMBER_LITERAL to state [127]
transition on break_statement to state [126]
transition on local_variable_declaration_statement to state [125]
transition on VAR to state [74]
transition on OBJECT to state [65]
transition on ARRAY to state [73]
transition on interface_declaration to state [124]
transition on modifier to state [12]
transition on PROTECTED to state [13]
transition on field_access to state [123]
transition on postfix_expression to state [122]
transition on LPAREN to state [89]
transition on LBRACE to state [47]
transition on postdecrement_expression to state [121]
transition on block to state [120]
transition on class_instance_creation_expression to state [119]
transition on try_statement to state [118]
transition on statement_expression to state [117]
transition on THROW to state [116]
transition on PASS to state [115]
transition on array_type to state [72]
transition on class_declaration to state [114]
transition on left_hand_side to state [113]
transition on array_access to state [112]
transition on switch_statement to state [111]
transition on block_statement to state [110]
transition on class_or_interface_type to state [62]
transition on IDENTIFIER to state [109]
transition on method_invocation to state [108]
transition on for_statement to state [107]
transition on block_statements to state [441]

-------------------
lalr_state [441]: {
  [switch_block_statement_group ::= switch_case_header block_statement terminators block_statements (*) , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [442]: {
  [switch_case_header ::= DEFAULT colon_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}

-------------------
lalr_state [443]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {COMMA RBRACE COLON NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {COMMA RBRACE COLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA RBRACE EQ COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {COMMA RBRACE COLON EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT COMMA RBRACE COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {COMMA RBRACE COLON NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {COMMA RBRACE COLON ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT COMMA RBRACE COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {COMMA RBRACE COLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {COMMA RBRACE COLON EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT COMMA RBRACE COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ LPAREN COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [constant_expression ::= (*) expression , {COMMA RBRACE COLON NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {COMMA RBRACE COLON ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT COMMA RBRACE COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {COMMA RBRACE COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {COMMA RBRACE COLON EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT COMMA RBRACE COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT COMMA RBRACE EQ LPAREN COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {COMMA RBRACE COLON OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT COMMA RBRACE COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {COMMA RBRACE COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {COMMA RBRACE COLON AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT COMMA RBRACE COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT COMMA RBRACE EQ LPAREN COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {COMMA RBRACE COLON OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RBRACE COLON PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {COMMA RBRACE COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {COMMA RBRACE COLON AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT COMMA RBRACE COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {COMMA RBRACE COLON NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {COMMA RBRACE COLON PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {COMMA RBRACE COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RBRACE COLON XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT COMMA RBRACE COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [switch_labels ::= switch_labels comma_multiline (*) switch_label , {COMMA RBRACE COLON NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {COMMA RBRACE COLON NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {COMMA RBRACE COLON PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {COMMA RBRACE COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {COMMA RBRACE COLON XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT COMMA RBRACE COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [switch_label ::= (*) constant_expression , {COMMA RBRACE COLON NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RBRACE COLON NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {COMMA RBRACE COLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {COMMA RBRACE COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT COMMA RBRACE COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RBRACE COLON OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT COMMA RBRACE COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {COMMA RBRACE COLON NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {COMMA RBRACE COLON LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA RBRACE EQ COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {COMMA RBRACE COLON LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT COMMA RBRACE COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {COMMA RBRACE COLON OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT COMMA RBRACE COLON PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT COMMA RBRACE COLON PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on switch_label to state [445]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on expression to state [434]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on constant_expression to state [432]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [444]: {
  [switch_block ::= lbrace_multiline switch_labels rbrace_multiline (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [445]: {
  [switch_labels ::= switch_labels comma_multiline switch_label (*) , {COMMA RBRACE COLON NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [446]: {
  [comma_multiline ::= (*) COMMA terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [switch_labels ::= switch_labels (*) comma_multiline switch_label , {COMMA COLON }]
  [switch_case_header ::= CASE switch_labels (*) colon_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [colon_multiline ::= (*) COLON terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on comma_multiline to state [443]
transition on colon_multiline to state [447]
transition on COLON to state [290]
transition on COMMA to state [36]

-------------------
lalr_state [447]: {
  [switch_case_header ::= CASE switch_labels colon_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}

-------------------
lalr_state [448]: {
  [switch_block ::= lbrace_multiline switch_block_statement_groups rbrace_multiline (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [449]: {
  [rbrace_multiline ::= (*) terminators_opt RBRACE , {ELSE WHILE NEWLINE ENDOFFILE }]
  [comma_multiline ::= (*) COMMA terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) NEWLINE , {RBRACE NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RBRACE }]
  [switch_labels ::= switch_labels (*) comma_multiline switch_label , {COMMA RBRACE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RBRACE }]
  [terminators_opt ::= (*) , {RBRACE }]
  [terminator ::= (*) ENDOFFILE , {RBRACE NEWLINE ENDOFFILE }]
  [switch_block ::= lbrace_multiline switch_block_statement_groups switch_labels (*) rbrace_multiline , {ELSE WHILE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RBRACE }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [312]
transition on comma_multiline to state [443]
transition on rbrace_multiline to state [451]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]
transition on COMMA to state [36]

-------------------
lalr_state [450]: {
  [switch_block_statement_groups ::= switch_block_statement_groups switch_block_statement_group (*) , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [451]: {
  [switch_block ::= lbrace_multiline switch_block_statement_groups switch_labels rbrace_multiline (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [452]: {
  [variable_declarator ::= variable_declarator_id (*) EQ variable_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [variable_declarator ::= variable_declarator_id (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on EQ to state [457]

-------------------
lalr_state [453]: {
  [variable_declarators ::= variable_declarator (*) COMMA variable_declarators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [variable_declarators ::= variable_declarator (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on COMMA to state [455]

-------------------
lalr_state [454]: {
  [local_variable_declaration ::= type variable_declarators (*) , {SEMICOLON NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [455]: {
  [variable_declarators ::= variable_declarator COMMA (*) variable_declarators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [variable_declarator_id ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE EQ PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [variable_declarators ::= (*) variable_declarator COMMA variable_declarators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [variable_declarator ::= (*) variable_declarator_id EQ variable_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [variable_declarators ::= (*) variable_declarator , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [variable_declarator ::= (*) variable_declarator_id , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on variable_declarators to state [456]
transition on IDENTIFIER to state [103]
transition on variable_declarator to state [453]
transition on variable_declarator_id to state [452]

-------------------
lalr_state [456]: {
  [variable_declarators ::= variable_declarator COMMA variable_declarators (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [457]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE EQ PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE EQ PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {COMMA LBRACE RBRACE LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE EQ LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE EQ PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [variable_declarator ::= variable_declarator_id EQ (*) variable_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE EQ LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE EQ PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_initializer ::= (*) lbrace_multiline variable_initializers COMMA rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE EQ LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [variable_initializer ::= (*) expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_initializer ::= (*) lbrace_multiline variable_initializers rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [variable_initializer ::= (*) array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [array_initializer ::= (*) lbrace_multiline comma_multiline rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_initializer ::= (*) lbrace_multiline rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE EQ PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK DOT SEMICOLON MULT COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on LBRACE to state [47]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on array_initializer to state [315]
transition on variable_initializer to state [458]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on postdecrement_expression to state [190]
transition on MINUSMINUS to state [162]
transition on unary_expression to state [189]
transition on expression to state [313]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on lbrace_multiline to state [309]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [458]: {
  [variable_declarator ::= variable_declarator_id EQ variable_initializer (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR SEMICOLON COMMA RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [459]: {
  [terminator ::= (*) NEWLINE , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [while_statement ::= WHILE expression (*) terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LBRACE LPAREN THIS SUPER IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [460]

-------------------
lalr_state [460]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [if_then_statement ::= (*) IF expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [throw_statement ::= (*) THROW expression , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) do_statement , {WHILE NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [do_statement ::= (*) DO terminators_opt statement terminators_opt WHILE expression , {WHILE NEWLINE ENDOFFILE }]
  [expression_statement ::= (*) statement_expression , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [try_statement ::= (*) TRY block terminators_opt catches , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) break_statement , {WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) assignment , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt catches terminators_opt finally , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) continue_statement , {WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) preincrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) statement_without_trailing_substatement , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [switch_statement ::= (*) SWITCH expression switch_block , {WHILE NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {WHILE NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt finally , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) return_statement , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) predecrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) labeled_statement , {WHILE NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) throw_statement , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postincrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_statement , {WHILE NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_without_trailing_substatement ::= (*) block , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) try_statement , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postdecrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_else_statement , {WHILE NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [break_statement ::= (*) BREAK identifier_opt , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) empty_statement , {WHILE NEWLINE ENDOFFILE }]
  [empty_statement ::= (*) PASS , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) method_invocation , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) while_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [continue_statement ::= (*) CONTINUE identifier_opt , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) expression_statement , {WHILE NEWLINE ENDOFFILE }]
  [while_statement ::= WHILE expression terminators (*) statement , {WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [while_statement ::= (*) WHILE expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [labeled_statement ::= (*) IDENTIFIER colon_multiline statement , {WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) class_instance_creation_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) for_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [return_statement ::= (*) RETURN expression_opt , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) switch_statement , {WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
}
transition on IDENTIFIER to state [109]
transition on DO to state [141]
transition on array_access to state [112]
transition on labeled_statement to state [157]
transition on if_then_else_statement to state [158]
transition on expression_statement to state [145]
transition on preincrement_expression to state [131]
transition on statement_without_trailing_substatement to state [139]
transition on try_statement to state [118]
transition on UNDEFINED_LITERAL to state [128]
transition on WHILE to state [136]
transition on method_invocation to state [108]
transition on while_statement to state [153]
transition on LBRACE to state [47]
transition on primary_no_new_array to state [164]
transition on throw_statement to state [161]
transition on class_instance_creation_expression to state [119]
transition on SWITCH to state [140]
transition on postfix_expression to state [122]
transition on BREAK to state [146]
transition on return_statement to state [133]
transition on TRY to state [144]
transition on do_statement to state [170]
transition on continue_statement to state [155]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on postdecrement_expression to state [121]
transition on MINUSMINUS to state [162]
transition on RETURN to state [143]
transition on statement to state [360]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on IF to state [160]
transition on NULL_LITERAL to state [148]
transition on primary to state [154]
transition on assignment to state [152]
transition on THROW to state [116]
transition on PASS to state [115]
transition on lparen_multiline to state [166]
transition on empty_statement to state [132]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on for_statement to state [107]
transition on lbrace_multiline to state [104]
transition on FOR to state [142]
transition on block to state [120]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [156]
transition on LPAREN to state [89]
transition on CONTINUE to state [159]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [163]
transition on switch_statement to state [111]
transition on break_statement to state [126]
transition on left_hand_side to state [113]
transition on if_then_statement to state [135]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]
transition on statement_expression to state [117]

-------------------
lalr_state [461]: {
  [method_invocation ::= SUPER DOT (*) IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= SUPER DOT (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [462]

-------------------
lalr_state [462]: {
  [method_invocation ::= SUPER DOT IDENTIFIER (*) lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= SUPER DOT IDENTIFIER (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN RPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on LPAREN to state [89]
transition on lparen_multiline to state [463]

-------------------
lalr_state [463]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {COMMA RPAREN ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {COMMA RPAREN OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list_opt ::= (*) , {RPAREN NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {COMMA RPAREN OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list_opt ::= (*) argument_list , {RPAREN NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {COMMA RPAREN AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list ::= (*) expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= SUPER DOT IDENTIFIER lparen_multiline (*) argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list ::= (*) argument_list comma_multiline expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {COMMA RPAREN XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {COMMA RPAREN OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on argument_list to state [192]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on expression to state [188]
transition on THIS to state [150]
transition on argument_list_opt to state [464]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [464]: {
  [terminator ::= (*) NEWLINE , {RPAREN NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RPAREN }]
  [terminators ::= (*) terminator terminators , {RPAREN }]
  [rparen_multiline ::= (*) terminators_opt RPAREN , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {RPAREN }]
  [terminator ::= (*) ENDOFFILE , {RPAREN NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RPAREN }]
  [method_invocation ::= SUPER DOT IDENTIFIER lparen_multiline argument_list_opt (*) rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [98]
transition on rparen_multiline to state [465]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [465]: {
  [method_invocation ::= SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [466]: {
  [throw_statement ::= THROW expression (*) , {ELSE WHILE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [467]: {
  [assignment_operator ::= XOREQ (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [468]: {
  [assignment_operator ::= MULTEQ (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [469]: {
  [assignment_operator ::= DIVEQ (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [470]: {
  [assignment_operator ::= ANDEQ (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [471]: {
  [assignment_operator ::= URSHIFTEQ (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [472]: {
  [assignment_operator ::= PLUSEQ (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [473]: {
  [assignment_operator ::= RSHIFTEQ (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [474]: {
  [assignment_operator ::= LSHIFTEQ (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [475]: {
  [assignment_operator ::= EQ (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [476]: {
  [assignment_operator ::= MINUSEQ (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [477]: {
  [terminator ::= (*) NEWLINE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [assignment ::= left_hand_side assignment_operator (*) terminators_opt assignment_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminators_opt ::= (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [terminator ::= (*) ENDOFFILE , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [480]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [478]: {
  [assignment_operator ::= OREQ (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [479]: {
  [assignment_operator ::= MODEQ (*) , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [480]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ LPAREN RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE EQ RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
  [assignment ::= left_hand_side assignment_operator terminators_opt (*) assignment_expression , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [481]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on class_instance_creation_expression to state [196]
transition on conditional_or_expression to state [197]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [481]: {
  [assignment ::= left_hand_side assignment_operator terminators_opt assignment_expression (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACK SEMICOLON COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [482]: {
  [block_statement ::= (*) interface_declaration , {NEWLINE ENDOFFILE }]
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [modifier ::= (*) PROTECTED , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [primitive_type ::= (*) BOOLEAN , {LBRACK IDENTIFIER }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [if_then_statement ::= (*) IF expression terminators statement , {NEWLINE ENDOFFILE }]
  [array_type ::= (*) ARRAY , {IDENTIFIER }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [throw_statement ::= (*) THROW expression , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) do_statement , {NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [do_statement ::= (*) DO terminators_opt statement terminators_opt WHILE expression , {NEWLINE ENDOFFILE }]
  [expression_statement ::= (*) statement_expression , {NEWLINE ENDOFFILE }]
  [local_variable_declaration_statement ::= (*) local_variable_declaration , {NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [modifier ::= (*) PRIVATE , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [primitive_type ::= (*) OBJECT , {LBRACK IDENTIFIER }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement , {NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [try_statement ::= (*) TRY block terminators_opt catches , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) break_statement , {NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) assignment , {NEWLINE ENDOFFILE }]
  [local_variable_declaration ::= (*) type variable_declarators , {NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [modifier ::= (*) STATIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [reference_type ::= (*) class_or_interface_type , {IDENTIFIER }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [try_statement ::= (*) TRY block terminators_opt catches terminators_opt finally , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) continue_statement , {NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) preincrement_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) statement_without_trailing_substatement , {NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [modifier ::= (*) ABSTRACT , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [reference_type ::= (*) array_type , {IDENTIFIER }]
  [switch_statement ::= (*) SWITCH expression switch_block , {NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ IDENTIFIER }]
  [try_statement ::= (*) TRY block terminators_opt finally , {NEWLINE ENDOFFILE }]
  [block_statements ::= block_statement terminators (*) , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) return_statement , {NEWLINE ENDOFFILE }]
  [block_statements ::= (*) block_statement terminators , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [modifiers_opt ::= (*) , {CLASS INTERFACE }]
  [type ::= (*) primitive_type , {IDENTIFIER }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) predecrement_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) labeled_statement , {NEWLINE ENDOFFILE }]
  [class_declaration ::= (*) modifiers_opt CLASS IDENTIFIER super_opt interfaces_opt class_body , {NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [class_or_interface_type ::= (*) name , {IDENTIFIER }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {NEWLINE ENDOFFILE }]
  [block_statements ::= block_statement terminators (*) block_statements , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) throw_statement , {NEWLINE ENDOFFILE }]
  [block_statements ::= (*) block_statement terminators block_statements , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [interface_declaration ::= (*) modifiers_opt INTERFACE IDENTIFIER extends_interfaces_opt interface_body , {NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [modifiers_opt ::= (*) modifiers , {CLASS INTERFACE }]
  [type ::= (*) reference_type , {IDENTIFIER }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postincrement_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_statement , {NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_without_trailing_substatement ::= (*) block , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) try_statement , {NEWLINE ENDOFFILE }]
  [block_statement ::= (*) local_variable_declaration_statement , {NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [modifiers ::= (*) modifier , {CLASS INTERFACE }]
  [type ::= (*) VAR , {IDENTIFIER }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postdecrement_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_else_statement , {NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [break_statement ::= (*) BREAK identifier_opt , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) empty_statement , {NEWLINE ENDOFFILE }]
  [empty_statement ::= (*) PASS , {NEWLINE ENDOFFILE }]
  [block_statement ::= (*) statement , {NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [modifiers ::= (*) modifier modifiers , {CLASS INTERFACE }]
  [primitive_type ::= (*) NUMBER , {LBRACK IDENTIFIER }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) method_invocation , {NEWLINE ENDOFFILE }]
  [statement ::= (*) while_statement , {NEWLINE ENDOFFILE }]
  [array_type ::= (*) primitive_type dims , {IDENTIFIER }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [continue_statement ::= (*) CONTINUE identifier_opt , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) expression_statement , {NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [while_statement ::= (*) WHILE expression terminators statement , {NEWLINE ENDOFFILE }]
  [labeled_statement ::= (*) IDENTIFIER colon_multiline statement , {NEWLINE ENDOFFILE }]
  [block_statement ::= (*) class_declaration , {NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [modifier ::= (*) PUBLIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [primitive_type ::= (*) STRING , {LBRACK IDENTIFIER }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) class_instance_creation_expression , {NEWLINE ENDOFFILE }]
  [statement ::= (*) for_statement , {NEWLINE ENDOFFILE }]
  [array_type ::= (*) name dims , {IDENTIFIER }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [return_statement ::= (*) RETURN expression_opt , {NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) switch_statement , {NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
}
transition on do_statement to state [170]
transition on STATIC to state [11]
transition on PRIVATE to state [15]
transition on literal to state [169]
transition on statement to state [168]
transition on STRING to state [67]
transition on NEW to state [167]
transition on lparen_multiline to state [166]
transition on PLUSPLUS to state [165]
transition on qualified_name to state [35]
transition on primary_no_new_array to state [164]
transition on postincrement_expression to state [163]
transition on MINUSMINUS to state [162]
transition on throw_statement to state [161]
transition on IF to state [160]
transition on CONTINUE to state [159]
transition on if_then_else_statement to state [158]
transition on labeled_statement to state [157]
transition on predecrement_expression to state [156]
transition on continue_statement to state [155]
transition on modifiers_opt to state [20]
transition on primary to state [154]
transition on while_statement to state [153]
transition on assignment to state [152]
transition on primitive_type to state [71]
transition on lbrace_multiline to state [104]
transition on THIS to state [150]
transition on STRING_LITERAL to state [149]
transition on modifiers to state [17]
transition on NULL_LITERAL to state [148]
transition on name to state [147]
transition on BREAK to state [146]
transition on expression_statement to state [145]
transition on TRY to state [144]
transition on PUBLIC to state [10]
transition on RETURN to state [143]
transition on FOR to state [142]
transition on DO to state [141]
transition on SWITCH to state [140]
transition on statement_without_trailing_substatement to state [139]
transition on type to state [138]
transition on BOOLEAN to state [66]
transition on array_creation_expression to state [137]
transition on reference_type to state [68]
transition on WHILE to state [136]
transition on if_then_statement to state [135]
transition on ABSTRACT to state [8]
transition on SUPER to state [134]
transition on return_statement to state [133]
transition on empty_statement to state [132]
transition on NUMBER to state [69]
transition on preincrement_expression to state [131]
transition on local_variable_declaration to state [130]
transition on BOOLEAN_LITERAL to state [129]
transition on UNDEFINED_LITERAL to state [128]
transition on NUMBER_LITERAL to state [127]
transition on break_statement to state [126]
transition on local_variable_declaration_statement to state [125]
transition on VAR to state [74]
transition on OBJECT to state [65]
transition on ARRAY to state [73]
transition on interface_declaration to state [124]
transition on modifier to state [12]
transition on PROTECTED to state [13]
transition on field_access to state [123]
transition on postfix_expression to state [122]
transition on LPAREN to state [89]
transition on LBRACE to state [47]
transition on postdecrement_expression to state [121]
transition on block to state [120]
transition on class_instance_creation_expression to state [119]
transition on try_statement to state [118]
transition on statement_expression to state [117]
transition on THROW to state [116]
transition on PASS to state [115]
transition on array_type to state [72]
transition on class_declaration to state [114]
transition on left_hand_side to state [113]
transition on array_access to state [112]
transition on switch_statement to state [111]
transition on block_statement to state [110]
transition on class_or_interface_type to state [62]
transition on IDENTIFIER to state [109]
transition on method_invocation to state [108]
transition on for_statement to state [107]
transition on block_statements to state [483]

-------------------
lalr_state [483]: {
  [block_statements ::= block_statement terminators block_statements (*) , {RBRACE LPAREN THIS SUPER CASE DEFAULT NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [484]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [if_then_statement ::= (*) IF expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [throw_statement ::= (*) THROW expression , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) do_statement , {WHILE NEWLINE ENDOFFILE }]
  [block ::= (*) lbrace_multiline block_statements_opt rbrace_multiline , {WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) array_creation_expression , {DOT PLUSPLUS MINUSMINUS }]
  [do_statement ::= (*) DO terminators_opt statement terminators_opt WHILE expression , {WHILE NEWLINE ENDOFFILE }]
  [expression_statement ::= (*) statement_expression , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) primary , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS THIS SUPER INTERFACE IF SWITCH DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [if_then_else_statement ::= (*) IF expression terminators statement_no_short_if ELSE terminators_opt statement , {WHILE NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT PLUSPLUS MINUSMINUS }]
  [try_statement ::= (*) TRY block terminators_opt catches , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) break_statement , {WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [for_statement ::= (*) FOR for_init_opt semicolon_multiline expression_opt semicolon_multiline for_update_opt terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [statement_expression ::= (*) assignment , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) name , {PLUSPLUS MINUSMINUS }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt catches terminators_opt finally , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) continue_statement , {WHILE NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) preincrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) statement_without_trailing_substatement , {WHILE NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [postfix_expression ::= (*) postincrement_expression , {PLUSPLUS MINUSMINUS }]
  [switch_statement ::= (*) SWITCH expression switch_block , {WHILE NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {WHILE NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT EQ LPAREN PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [try_statement ::= (*) TRY block terminators_opt finally , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) return_statement , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) predecrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) labeled_statement , {WHILE NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {PLUSPLUS MINUSMINUS }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) throw_statement , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postincrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_statement , {WHILE NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [statement_without_trailing_substatement ::= (*) block , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) try_statement , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) postdecrement_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) if_then_else_statement , {WHILE NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [break_statement ::= (*) BREAK identifier_opt , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) empty_statement , {WHILE NEWLINE ENDOFFILE }]
  [empty_statement ::= (*) PASS , {WHILE NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT WHILE PLUSPLUS MINUSMINUS NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) method_invocation , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) while_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [continue_statement ::= (*) CONTINUE identifier_opt , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) expression_statement , {WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [labeled_statement ::= IDENTIFIER colon_multiline (*) statement , {WHILE NEWLINE ENDOFFILE }]
  [while_statement ::= (*) WHILE expression terminators statement , {WHILE NEWLINE ENDOFFILE }]
  [labeled_statement ::= (*) IDENTIFIER colon_multiline statement , {WHILE NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT EQ PLUSPLUS MINUSMINUS MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [statement_expression ::= (*) class_instance_creation_expression , {WHILE NEWLINE ENDOFFILE }]
  [statement ::= (*) for_statement , {WHILE NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT PLUSPLUS MINUSMINUS }]
  [return_statement ::= (*) RETURN expression_opt , {WHILE NEWLINE ENDOFFILE }]
  [statement_without_trailing_substatement ::= (*) switch_statement , {WHILE NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT PLUSPLUS MINUSMINUS }]
  [primary ::= (*) primary_no_new_array , {DOT PLUSPLUS MINUSMINUS }]
}
transition on IDENTIFIER to state [109]
transition on DO to state [141]
transition on array_access to state [112]
transition on labeled_statement to state [157]
transition on if_then_else_statement to state [158]
transition on expression_statement to state [145]
transition on preincrement_expression to state [131]
transition on statement_without_trailing_substatement to state [139]
transition on try_statement to state [118]
transition on UNDEFINED_LITERAL to state [128]
transition on WHILE to state [136]
transition on method_invocation to state [108]
transition on while_statement to state [153]
transition on LBRACE to state [47]
transition on primary_no_new_array to state [164]
transition on throw_statement to state [161]
transition on class_instance_creation_expression to state [119]
transition on SWITCH to state [140]
transition on postfix_expression to state [122]
transition on BREAK to state [146]
transition on return_statement to state [133]
transition on TRY to state [144]
transition on do_statement to state [170]
transition on continue_statement to state [155]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on postdecrement_expression to state [121]
transition on MINUSMINUS to state [162]
transition on RETURN to state [143]
transition on statement to state [356]
transition on qualified_name to state [35]
transition on THIS to state [150]
transition on IF to state [160]
transition on NULL_LITERAL to state [148]
transition on primary to state [154]
transition on assignment to state [152]
transition on THROW to state [116]
transition on PASS to state [115]
transition on lparen_multiline to state [166]
transition on empty_statement to state [132]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on for_statement to state [107]
transition on lbrace_multiline to state [104]
transition on FOR to state [142]
transition on block to state [120]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [156]
transition on LPAREN to state [89]
transition on CONTINUE to state [159]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [163]
transition on switch_statement to state [111]
transition on break_statement to state [126]
transition on left_hand_side to state [113]
transition on if_then_statement to state [135]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]
transition on statement_expression to state [117]

-------------------
lalr_state [485]: {
  [formal_parameter_list ::= (*) formal_parameter , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [type ::= (*) primitive_type , {IDENTIFIER }]
  [primitive_type ::= (*) BOOLEAN , {LBRACK IDENTIFIER }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT IDENTIFIER }]
  [formal_parameter_list_opt ::= (*) , {RPAREN NEWLINE ENDOFFILE }]
  [formal_parameter ::= (*) variable_declarator_id , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [primitive_type ::= (*) NUMBER , {LBRACK IDENTIFIER }]
  [reference_type ::= (*) array_type , {IDENTIFIER }]
  [variable_declarator_id ::= (*) IDENTIFIER , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [array_type ::= (*) name dims , {IDENTIFIER }]
  [formal_parameter_list ::= (*) formal_parameter_list comma_multiline formal_parameter , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [type ::= (*) reference_type , {IDENTIFIER }]
  [primitive_type ::= (*) OBJECT , {LBRACK IDENTIFIER }]
  [name ::= (*) qualified_name , {LBRACK DOT IDENTIFIER }]
  [formal_parameter_list_opt ::= (*) formal_parameter_list , {RPAREN NEWLINE ENDOFFILE }]
  [primitive_type ::= (*) STRING , {LBRACK IDENTIFIER }]
  [class_or_interface_type ::= (*) name , {IDENTIFIER }]
  [array_type ::= (*) ARRAY , {IDENTIFIER }]
  [formal_parameter ::= (*) type variable_declarator_id , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [type ::= (*) VAR , {IDENTIFIER }]
  [reference_type ::= (*) class_or_interface_type , {IDENTIFIER }]
  [array_type ::= (*) primitive_type dims , {IDENTIFIER }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT IDENTIFIER }]
  [constructor_declarator ::= IDENTIFIER lparen_multiline (*) formal_parameter_list_opt rparen_multiline explicit_constructor_invocation_opt , {LBRACE }]
}
transition on name to state [75]
transition on VAR to state [74]
transition on ARRAY to state [73]
transition on array_type to state [72]
transition on formal_parameter to state [96]
transition on qualified_name to state [35]
transition on primitive_type to state [71]
transition on variable_declarator_id to state [95]
transition on NUMBER to state [69]
transition on reference_type to state [68]
transition on STRING to state [67]
transition on formal_parameter_list_opt to state [486]
transition on BOOLEAN to state [66]
transition on OBJECT to state [65]
transition on formal_parameter_list to state [93]
transition on IDENTIFIER to state [92]
transition on class_or_interface_type to state [62]
transition on type to state [91]

-------------------
lalr_state [486]: {
  [terminator ::= (*) NEWLINE , {RPAREN NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RPAREN }]
  [terminators ::= (*) terminator terminators , {RPAREN }]
  [rparen_multiline ::= (*) terminators_opt RPAREN , {LBRACE COLON }]
  [terminators_opt ::= (*) , {RPAREN }]
  [terminator ::= (*) ENDOFFILE , {RPAREN NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RPAREN }]
  [constructor_declarator ::= IDENTIFIER lparen_multiline formal_parameter_list_opt (*) rparen_multiline explicit_constructor_invocation_opt , {LBRACE }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [98]
transition on rparen_multiline to state [487]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [487]: {
  [explicit_constructor_invocation_opt ::= (*) colon_multiline explicit_constructor_invocation , {LBRACE }]
  [colon_multiline ::= (*) COLON terminators_opt , {THIS SUPER }]
  [explicit_constructor_invocation_opt ::= (*) , {LBRACE }]
  [constructor_declarator ::= IDENTIFIER lparen_multiline formal_parameter_list_opt rparen_multiline (*) explicit_constructor_invocation_opt , {LBRACE }]
}
transition on explicit_constructor_invocation_opt to state [489]
transition on colon_multiline to state [488]
transition on COLON to state [290]

-------------------
lalr_state [488]: {
  [explicit_constructor_invocation ::= (*) THIS lparen_multiline argument_list_opt rparen_multiline terminators , {LBRACE }]
  [explicit_constructor_invocation_opt ::= colon_multiline (*) explicit_constructor_invocation , {LBRACE }]
  [explicit_constructor_invocation ::= (*) SUPER lparen_multiline argument_list_opt rparen_multiline terminators , {LBRACE }]
}
transition on THIS to state [492]
transition on explicit_constructor_invocation to state [491]
transition on SUPER to state [490]

-------------------
lalr_state [489]: {
  [constructor_declarator ::= IDENTIFIER lparen_multiline formal_parameter_list_opt rparen_multiline explicit_constructor_invocation_opt (*) , {LBRACE }]
}

-------------------
lalr_state [490]: {
  [explicit_constructor_invocation ::= SUPER (*) lparen_multiline argument_list_opt rparen_multiline terminators , {LBRACE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN RPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on LPAREN to state [89]
transition on lparen_multiline to state [497]

-------------------
lalr_state [491]: {
  [explicit_constructor_invocation_opt ::= colon_multiline explicit_constructor_invocation (*) , {LBRACE }]
}

-------------------
lalr_state [492]: {
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN RPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
  [explicit_constructor_invocation ::= THIS (*) lparen_multiline argument_list_opt rparen_multiline terminators , {LBRACE }]
}
transition on LPAREN to state [89]
transition on lparen_multiline to state [493]

-------------------
lalr_state [493]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {COMMA RPAREN ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [explicit_constructor_invocation ::= THIS lparen_multiline (*) argument_list_opt rparen_multiline terminators , {LBRACE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {COMMA RPAREN OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list_opt ::= (*) , {RPAREN NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {COMMA RPAREN OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list_opt ::= (*) argument_list , {RPAREN NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {COMMA RPAREN AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list ::= (*) expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list ::= (*) argument_list comma_multiline expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {COMMA RPAREN XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {COMMA RPAREN OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on argument_list to state [192]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on expression to state [188]
transition on THIS to state [150]
transition on argument_list_opt to state [494]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [494]: {
  [terminator ::= (*) NEWLINE , {RPAREN NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RPAREN }]
  [terminators ::= (*) terminator terminators , {RPAREN }]
  [rparen_multiline ::= (*) terminators_opt RPAREN , {NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {RPAREN }]
  [terminator ::= (*) ENDOFFILE , {RPAREN NEWLINE ENDOFFILE }]
  [explicit_constructor_invocation ::= THIS lparen_multiline argument_list_opt (*) rparen_multiline terminators , {LBRACE }]
  [terminators ::= (*) terminator , {RPAREN }]
}
transition on NEWLINE to state [43]
transition on terminators_opt to state [98]
transition on rparen_multiline to state [495]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [495]: {
  [terminator ::= (*) NEWLINE , {LBRACE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {LBRACE }]
  [explicit_constructor_invocation ::= THIS lparen_multiline argument_list_opt rparen_multiline (*) terminators , {LBRACE }]
  [terminator ::= (*) ENDOFFILE , {LBRACE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LBRACE }]
}
transition on NEWLINE to state [43]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [496]

-------------------
lalr_state [496]: {
  [explicit_constructor_invocation ::= THIS lparen_multiline argument_list_opt rparen_multiline terminators (*) , {LBRACE }]
}

-------------------
lalr_state [497]: {
  [assignment ::= (*) left_hand_side assignment_operator terminators_opt assignment_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression RSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) primary_no_new_array lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) name DOT THIS , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) PLUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dims array_initializer , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MULT terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) primary DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [literal ::= (*) STRING_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) array_creation_expression , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) name , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [shift_expression ::= (*) shift_expression URSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) primary , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression EQEQ terminators_opt relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) MINUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dims array_initializer , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_and_expression ::= (*) conditional_and_expression ANDAND terminators_opt inclusive_or_expression , {COMMA RPAREN ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression DIV terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) literal , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NULL_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) field_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) name , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [class_instance_creation_expression ::= (*) NEW class_type lparen_multiline argument_list_opt rparen_multiline class_body , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [equality_expression ::= (*) equality_expression NOTEQ terminators_opt relational_expression , {COMMA RPAREN EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) unary_expression_not_plus_minus , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [name ::= (*) qualified_name , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [conditional_or_expression ::= (*) conditional_and_expression , {COMMA RPAREN OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MOD terminators_opt unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [field_access ::= (*) name DOT SUPER DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) THIS , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) UNDEFINED_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [left_hand_side ::= (*) array_access , {EQ MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ }]
  [relational_expression ::= (*) relational_expression LT terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postincrement_expression , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list_opt ::= (*) , {RPAREN NEWLINE ENDOFFILE }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [preincrement_expression ::= (*) PLUSPLUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT MULT COMMA EQ LPAREN RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [explicit_constructor_invocation ::= SUPER lparen_multiline (*) argument_list_opt rparen_multiline terminators , {LBRACE }]
  [conditional_or_expression ::= (*) conditional_or_expression OROR terminators_opt conditional_and_expression , {COMMA RPAREN OROR QUESTION NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) lparen_multiline expression rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GT terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postfix_expression ::= (*) postdecrement_expression , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list_opt ::= (*) argument_list , {RPAREN NEWLINE ENDOFFILE }]
  [and_expression ::= (*) and_expression AND terminators_opt equality_expression , {COMMA RPAREN AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [predecrement_expression ::= (*) MINUSMINUS unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression PLUS terminators_opt multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) primary DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) class_instance_creation_expression , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression LTEQ terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postincrement_expression ::= (*) postfix_expression PLUSPLUS , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list ::= (*) expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {LPAREN THIS SUPER NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) postfix_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [conditional_expression ::= (*) conditional_or_expression question_multiline expression colon_multiline conditional_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [additive_expression ::= (*) additive_expression MINUS terminators_opt multiplicative_expression , {COMMA RPAREN PLUS MINUS LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) field_access , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression GTEQ terminators_opt shift_expression , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [postdecrement_expression ::= (*) postfix_expression MINUSMINUS , {MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [argument_list ::= (*) argument_list comma_multiline expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [exclusive_or_expression ::= (*) exclusive_or_expression XOR terminators_opt and_expression , {COMMA RPAREN XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) COMP unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [method_invocation ::= (*) name DOT SUPER DOT IDENTIFIER lparen_multiline argument_list_opt rparen_multiline , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) method_invocation , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression IS terminators_opt reference_type , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) preincrement_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW primitive_type dim_exprs dims_opt , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression_not_plus_minus ::= (*) NOT unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) NUMBER_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [assignment_expression ::= (*) assignment , {COMMA RPAREN NEWLINE ENDOFFILE }]
  [shift_expression ::= (*) shift_expression LSHIFT terminators_opt additive_expression , {COMMA RPAREN LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_access ::= (*) name lbrack_multiline expression rbrack_multiline , {LBRACK DOT MULT COMMA EQ RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION MULTEQ DIVEQ MODEQ PLUSEQ MINUSEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ ANDEQ XOREQ OREQ NEWLINE ENDOFFILE }]
  [primary_no_new_array ::= (*) array_access , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [relational_expression ::= (*) relational_expression ISNT terminators_opt reference_type , {COMMA RPAREN LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [unary_expression ::= (*) predecrement_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [array_creation_expression ::= (*) NEW class_or_interface_type dim_exprs dims_opt , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression OR terminators_opt exclusive_or_expression , {COMMA RPAREN OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [multiplicative_expression ::= (*) unary_expression , {MULT COMMA RPAREN PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [primary ::= (*) primary_no_new_array , {DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
  [literal ::= (*) BOOLEAN_LITERAL , {LBRACK DOT MULT COMMA RPAREN PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [34]
transition on array_access to state [112]
transition on relational_expression to state [204]
transition on multiplicative_expression to state [203]
transition on preincrement_expression to state [202]
transition on UNDEFINED_LITERAL to state [128]
transition on method_invocation to state [201]
transition on assignment_expression to state [200]
transition on inclusive_or_expression to state [199]
transition on primary_no_new_array to state [164]
transition on and_expression to state [198]
transition on conditional_or_expression to state [197]
transition on class_instance_creation_expression to state [196]
transition on shift_expression to state [195]
transition on unary_expression_not_plus_minus to state [194]
transition on postfix_expression to state [193]
transition on argument_list to state [192]
transition on conditional_expression to state [191]
transition on NEW to state [167]
transition on SUPER to state [134]
transition on MINUSMINUS to state [162]
transition on postdecrement_expression to state [190]
transition on unary_expression to state [189]
transition on qualified_name to state [35]
transition on expression to state [188]
transition on argument_list_opt to state [498]
transition on THIS to state [150]
transition on NULL_LITERAL to state [148]
transition on PLUS to state [186]
transition on primary to state [154]
transition on COMP to state [185]
transition on assignment to state [184]
transition on lparen_multiline to state [166]
transition on exclusive_or_expression to state [183]
transition on equality_expression to state [182]
transition on NOT to state [181]
transition on name to state [180]
transition on BOOLEAN_LITERAL to state [129]
transition on MINUS to state [179]
transition on array_creation_expression to state [137]
transition on literal to state [169]
transition on predecrement_expression to state [178]
transition on LPAREN to state [89]
transition on NUMBER_LITERAL to state [127]
transition on postincrement_expression to state [177]
transition on conditional_and_expression to state [176]
transition on additive_expression to state [175]
transition on left_hand_side to state [113]
transition on STRING_LITERAL to state [149]
transition on PLUSPLUS to state [165]
transition on field_access to state [123]

-------------------
lalr_state [498]: {
  [terminator ::= (*) NEWLINE , {RPAREN NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RPAREN }]
  [explicit_constructor_invocation ::= SUPER lparen_multiline argument_list_opt (*) rparen_multiline terminators , {LBRACE }]
  [terminators ::= (*) terminator terminators , {RPAREN }]
  [rparen_multiline ::= (*) terminators_opt RPAREN , {NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) , {RPAREN }]
  [terminator ::= (*) ENDOFFILE , {RPAREN NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RPAREN }]
}
transition on NEWLINE to state [43]
transition on rparen_multiline to state [499]
transition on terminators_opt to state [98]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [499]: {
  [terminator ::= (*) NEWLINE , {LBRACE NEWLINE ENDOFFILE }]
  [explicit_constructor_invocation ::= SUPER lparen_multiline argument_list_opt rparen_multiline (*) terminators , {LBRACE }]
  [terminators ::= (*) terminator terminators , {LBRACE }]
  [terminator ::= (*) ENDOFFILE , {LBRACE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {LBRACE }]
}
transition on NEWLINE to state [43]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [500]

-------------------
lalr_state [500]: {
  [explicit_constructor_invocation ::= SUPER lparen_multiline argument_list_opt rparen_multiline terminators (*) , {LBRACE }]
}

-------------------
lalr_state [501]: {
  [method_header ::= modifiers_opt type method_declarator (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [502]: {
  [variable_declarator_id ::= IDENTIFIER (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR COMMA RBRACE EQ PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [lparen_multiline ::= (*) LPAREN terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RPAREN IDENTIFIER NEWLINE ENDOFFILE }]
  [method_declarator ::= IDENTIFIER (*) lparen_multiline formal_parameter_list_opt rparen_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACE RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on LPAREN to state [89]
transition on lparen_multiline to state [88]

-------------------
lalr_state [503]: {
  [field_declaration ::= modifiers_opt type variable_declarators (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [504]: {
  [modifiers_opt ::= (*) modifiers , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [interface_declaration ::= (*) modifiers_opt INTERFACE IDENTIFIER extends_interfaces_opt interface_body , {NEWLINE ENDOFFILE }]
  [modifier ::= (*) PRIVATE , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT DEF IDENTIFIER }]
  [class_body_declarations ::= class_body_declaration terminators (*) , {RBRACE NEWLINE ENDOFFILE }]
  [class_body_declarations ::= (*) class_body_declaration terminators , {RBRACE NEWLINE ENDOFFILE }]
  [class_member_declaration ::= (*) method_declaration , {NEWLINE ENDOFFILE }]
  [modifier ::= (*) PUBLIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT DEF IDENTIFIER }]
  [class_declaration ::= (*) modifiers_opt CLASS IDENTIFIER super_opt interfaces_opt class_body , {NEWLINE ENDOFFILE }]
  [class_body_declaration ::= (*) constructor_declaration , {NEWLINE ENDOFFILE }]
  [field_declaration ::= (*) modifiers_opt type variable_declarators , {NEWLINE ENDOFFILE }]
  [method_header ::= (*) modifiers_opt DEF method_declarator , {LBRACE }]
  [modifiers ::= (*) modifier , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [modifier ::= (*) STATIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT DEF IDENTIFIER }]
  [class_body_declarations ::= class_body_declaration terminators (*) class_body_declarations , {RBRACE NEWLINE ENDOFFILE }]
  [class_body_declarations ::= (*) class_body_declaration terminators class_body_declarations , {RBRACE NEWLINE ENDOFFILE }]
  [class_member_declaration ::= (*) class_declaration , {NEWLINE ENDOFFILE }]
  [method_declaration ::= (*) method_header block , {NEWLINE ENDOFFILE }]
  [modifiers_opt ::= (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [constructor_declaration ::= (*) modifiers_opt constructor_declarator block , {NEWLINE ENDOFFILE }]
  [modifier ::= (*) PROTECTED , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT DEF IDENTIFIER }]
  [class_member_declaration ::= (*) field_declaration , {NEWLINE ENDOFFILE }]
  [modifiers ::= (*) modifier modifiers , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [modifier ::= (*) ABSTRACT , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT DEF IDENTIFIER }]
  [class_body_declaration ::= (*) class_member_declaration , {NEWLINE ENDOFFILE }]
  [class_member_declaration ::= (*) interface_declaration , {NEWLINE ENDOFFILE }]
  [method_header ::= (*) modifiers_opt type method_declarator , {LBRACE }]
}
transition on modifiers_opt to state [57]
transition on class_declaration to state [52]
transition on class_member_declaration to state [60]
transition on modifiers to state [17]
transition on field_declaration to state [58]
transition on class_body_declaration to state [55]
transition on interface_declaration to state [59]
transition on PRIVATE to state [15]
transition on class_body_declarations to state [505]
transition on PROTECTED to state [13]
transition on method_declaration to state [51]
transition on constructor_declaration to state [50]
transition on modifier to state [12]
transition on PUBLIC to state [10]
transition on STATIC to state [11]
transition on method_header to state [53]
transition on ABSTRACT to state [8]

-------------------
lalr_state [505]: {
  [class_body_declarations ::= class_body_declaration terminators class_body_declarations (*) , {RBRACE NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [506]: {
  [class_body ::= lbrace_multiline class_body_declarations_opt rbrace_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR LBRACK RBRACK DOT SEMICOLON MULT COMMA LBRACE RBRACE RPAREN COLON PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE ELSE WHILE PLUSPLUS MINUSMINUS PLUS MINUS DIV MOD LSHIFT RSHIFT URSHIFT LT GT LTEQ GTEQ IS ISNT EQEQ NOTEQ AND XOR OR ANDAND OROR QUESTION IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [507]: {
  [method_declaration ::= method_header block (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [508]: {
  [lbrace_multiline ::= LBRACE terminators_opt (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR COMMA LBRACE RBRACE LPAREN PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF THIS SUPER INTERFACE IF SWITCH CASE DEFAULT DO WHILE FOR BREAK CONTINUE RETURN THROW TRY NEW PLUSPLUS MINUSMINUS PLUS MINUS COMP NOT PASS NUMBER_LITERAL BOOLEAN_LITERAL STRING_LITERAL NULL_LITERAL UNDEFINED_LITERAL IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [509]: {
  [class_type ::= class_or_interface_type (*) , {LBRACE IMPLEMENTS }]
}

-------------------
lalr_state [510]: {
  [super_cl ::= EXTENDS class_type (*) , {LBRACE IMPLEMENTS }]
}

-------------------
lalr_state [511]: {
  [interface_declaration ::= modifiers_opt INTERFACE IDENTIFIER (*) extends_interfaces_opt interface_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [extends_interfaces ::= (*) EXTENDS interface_type , {COMMA LBRACE }]
  [extends_interfaces_opt ::= (*) extends_interfaces , {LBRACE }]
  [extends_interfaces ::= (*) extends_interfaces comma_multiline interface_type , {COMMA LBRACE }]
  [extends_interfaces_opt ::= (*) , {LBRACE }]
}
transition on extends_interfaces to state [514]
transition on extends_interfaces_opt to state [513]
transition on EXTENDS to state [512]

-------------------
lalr_state [512]: {
  [interface_type ::= (*) class_or_interface_type , {COMMA LBRACE }]
  [extends_interfaces ::= EXTENDS (*) interface_type , {COMMA LBRACE }]
  [name ::= (*) qualified_name , {DOT COMMA LBRACE }]
  [name ::= (*) IDENTIFIER , {DOT COMMA LBRACE }]
  [class_or_interface_type ::= (*) name , {COMMA LBRACE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {DOT COMMA LBRACE }]
}
transition on qualified_name to state [35]
transition on IDENTIFIER to state [34]
transition on class_or_interface_type to state [33]
transition on interface_type to state [532]
transition on name to state [31]

-------------------
lalr_state [513]: {
  [lbrace_multiline ::= (*) LBRACE terminators_opt , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [interface_body ::= (*) lbrace_multiline interface_member_declarations_opt rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [interface_declaration ::= modifiers_opt INTERFACE IDENTIFIER extends_interfaces_opt (*) interface_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on interface_body to state [518]
transition on lbrace_multiline to state [517]
transition on LBRACE to state [47]

-------------------
lalr_state [514]: {
  [comma_multiline ::= (*) COMMA terminators_opt , {IDENTIFIER }]
  [extends_interfaces_opt ::= extends_interfaces (*) , {LBRACE }]
  [extends_interfaces ::= extends_interfaces (*) comma_multiline interface_type , {COMMA LBRACE }]
}
transition on comma_multiline to state [515]
transition on COMMA to state [36]

-------------------
lalr_state [515]: {
  [interface_type ::= (*) class_or_interface_type , {COMMA LBRACE }]
  [name ::= (*) qualified_name , {DOT COMMA LBRACE }]
  [name ::= (*) IDENTIFIER , {DOT COMMA LBRACE }]
  [extends_interfaces ::= extends_interfaces comma_multiline (*) interface_type , {COMMA LBRACE }]
  [class_or_interface_type ::= (*) name , {COMMA LBRACE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {DOT COMMA LBRACE }]
}
transition on qualified_name to state [35]
transition on IDENTIFIER to state [34]
transition on class_or_interface_type to state [33]
transition on interface_type to state [516]
transition on name to state [31]

-------------------
lalr_state [516]: {
  [extends_interfaces ::= extends_interfaces comma_multiline interface_type (*) , {COMMA LBRACE }]
}

-------------------
lalr_state [517]: {
  [modifiers_opt ::= (*) modifiers , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [modifier ::= (*) PRIVATE , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [interface_body ::= lbrace_multiline (*) interface_member_declarations_opt rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [interface_declaration ::= (*) modifiers_opt INTERFACE IDENTIFIER extends_interfaces_opt interface_body , {NEWLINE ENDOFFILE }]
  [interface_member_declaration ::= (*) constant_declaration , {NEWLINE ENDOFFILE }]
  [abstract_method_declaration ::= (*) method_header , {NEWLINE ENDOFFILE }]
  [modifier ::= (*) PUBLIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [class_declaration ::= (*) modifiers_opt CLASS IDENTIFIER super_opt interfaces_opt class_body , {NEWLINE ENDOFFILE }]
  [interface_member_declarations ::= (*) interface_member_declaration terminators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [interface_member_declaration ::= (*) interface_declaration , {NEWLINE ENDOFFILE }]
  [field_declaration ::= (*) modifiers_opt type variable_declarators , {NEWLINE ENDOFFILE }]
  [method_header ::= (*) modifiers_opt DEF method_declarator , {NEWLINE ENDOFFILE }]
  [modifiers ::= (*) modifier , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [modifier ::= (*) STATIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [interface_member_declarations_opt ::= (*) , {RBRACE NEWLINE ENDOFFILE }]
  [interface_member_declaration ::= (*) abstract_method_declaration , {NEWLINE ENDOFFILE }]
  [modifiers_opt ::= (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [modifier ::= (*) PROTECTED , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [interface_member_declarations ::= (*) interface_member_declarations interface_member_declaration , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [constant_declaration ::= (*) field_declaration , {NEWLINE ENDOFFILE }]
  [modifiers ::= (*) modifier modifiers , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [modifier ::= (*) ABSTRACT , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [interface_member_declarations_opt ::= (*) interface_member_declarations , {RBRACE NEWLINE ENDOFFILE }]
  [interface_member_declaration ::= (*) class_declaration , {NEWLINE ENDOFFILE }]
  [method_header ::= (*) modifiers_opt type method_declarator , {NEWLINE ENDOFFILE }]
}
transition on modifiers_opt to state [528]
transition on class_declaration to state [527]
transition on modifiers to state [17]
transition on field_declaration to state [526]
transition on interface_declaration to state [525]
transition on interface_member_declaration to state [524]
transition on PRIVATE to state [15]
transition on interface_member_declarations_opt to state [523]
transition on abstract_method_declaration to state [522]
transition on PROTECTED to state [13]
transition on constant_declaration to state [521]
transition on modifier to state [12]
transition on method_header to state [520]
transition on PUBLIC to state [10]
transition on STATIC to state [11]
transition on interface_member_declarations to state [519]
transition on ABSTRACT to state [8]

-------------------
lalr_state [518]: {
  [interface_declaration ::= modifiers_opt INTERFACE IDENTIFIER extends_interfaces_opt interface_body (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [519]: {
  [modifiers_opt ::= (*) modifiers , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [modifier ::= (*) PRIVATE , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [interface_declaration ::= (*) modifiers_opt INTERFACE IDENTIFIER extends_interfaces_opt interface_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [interface_member_declaration ::= (*) constant_declaration , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [abstract_method_declaration ::= (*) method_header , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [modifier ::= (*) PUBLIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [class_declaration ::= (*) modifiers_opt CLASS IDENTIFIER super_opt interfaces_opt class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [interface_member_declaration ::= (*) interface_declaration , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [field_declaration ::= (*) modifiers_opt type variable_declarators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [method_header ::= (*) modifiers_opt DEF method_declarator , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [modifiers ::= (*) modifier , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [modifier ::= (*) STATIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [interface_member_declaration ::= (*) abstract_method_declaration , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [modifiers_opt ::= (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [modifier ::= (*) PROTECTED , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [interface_member_declarations ::= interface_member_declarations (*) interface_member_declaration , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [constant_declaration ::= (*) field_declaration , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [modifiers ::= (*) modifier modifiers , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
  [modifier ::= (*) ABSTRACT , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [interface_member_declarations_opt ::= interface_member_declarations (*) , {RBRACE NEWLINE ENDOFFILE }]
  [interface_member_declaration ::= (*) class_declaration , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [method_header ::= (*) modifiers_opt type method_declarator , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on modifiers_opt to state [528]
transition on class_declaration to state [527]
transition on modifiers to state [17]
transition on field_declaration to state [526]
transition on interface_declaration to state [525]
transition on PRIVATE to state [15]
transition on interface_member_declaration to state [531]
transition on abstract_method_declaration to state [522]
transition on PROTECTED to state [13]
transition on constant_declaration to state [521]
transition on modifier to state [12]
transition on method_header to state [520]
transition on PUBLIC to state [10]
transition on STATIC to state [11]
transition on ABSTRACT to state [8]

-------------------
lalr_state [520]: {
  [abstract_method_declaration ::= method_header (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [521]: {
  [interface_member_declaration ::= constant_declaration (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [522]: {
  [interface_member_declaration ::= abstract_method_declaration (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [523]: {
  [terminator ::= (*) NEWLINE , {RBRACE NEWLINE ENDOFFILE }]
  [terminators_opt ::= (*) terminators , {RBRACE }]
  [interface_body ::= lbrace_multiline interface_member_declarations_opt (*) rbrace_multiline , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {RBRACE }]
  [terminators_opt ::= (*) , {RBRACE }]
  [terminator ::= (*) ENDOFFILE , {RBRACE NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {RBRACE }]
  [rbrace_multiline ::= (*) terminators_opt RBRACE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on rbrace_multiline to state [530]
transition on terminators_opt to state [312]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [39]

-------------------
lalr_state [524]: {
  [terminator ::= (*) NEWLINE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [interface_member_declarations ::= interface_member_declaration (*) terminators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator terminators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [terminator ::= (*) ENDOFFILE , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [terminators ::= (*) terminator , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}
transition on NEWLINE to state [43]
transition on ENDOFFILE to state [41]
transition on terminator to state [40]
transition on terminators to state [529]

-------------------
lalr_state [525]: {
  [interface_member_declaration ::= interface_declaration (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [526]: {
  [constant_declaration ::= field_declaration (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [527]: {
  [interface_member_declaration ::= class_declaration (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [528]: {
  [interface_declaration ::= modifiers_opt (*) INTERFACE IDENTIFIER extends_interfaces_opt interface_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [type ::= (*) primitive_type , {IDENTIFIER }]
  [primitive_type ::= (*) BOOLEAN , {LBRACK IDENTIFIER }]
  [name ::= (*) IDENTIFIER , {LBRACK DOT IDENTIFIER }]
  [class_declaration ::= modifiers_opt (*) CLASS IDENTIFIER super_opt interfaces_opt class_body , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [primitive_type ::= (*) NUMBER , {LBRACK IDENTIFIER }]
  [field_declaration ::= modifiers_opt (*) type variable_declarators , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [reference_type ::= (*) array_type , {IDENTIFIER }]
  [method_header ::= modifiers_opt (*) DEF method_declarator , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [array_type ::= (*) name dims , {IDENTIFIER }]
  [type ::= (*) reference_type , {IDENTIFIER }]
  [primitive_type ::= (*) OBJECT , {LBRACK IDENTIFIER }]
  [name ::= (*) qualified_name , {LBRACK DOT IDENTIFIER }]
  [primitive_type ::= (*) STRING , {LBRACK IDENTIFIER }]
  [class_or_interface_type ::= (*) name , {IDENTIFIER }]
  [array_type ::= (*) ARRAY , {IDENTIFIER }]
  [type ::= (*) VAR , {IDENTIFIER }]
  [reference_type ::= (*) class_or_interface_type , {IDENTIFIER }]
  [array_type ::= (*) primitive_type dims , {IDENTIFIER }]
  [method_header ::= modifiers_opt (*) type method_declarator , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
  [qualified_name ::= (*) name DOT IDENTIFIER , {LBRACK DOT IDENTIFIER }]
}
transition on CLASS to state [22]
transition on array_type to state [72]
transition on IDENTIFIER to state [34]
transition on reference_type to state [68]
transition on DEF to state [70]
transition on INTERFACE to state [21]
transition on type to state [61]
transition on primitive_type to state [71]
transition on qualified_name to state [35]
transition on VAR to state [74]
transition on STRING to state [67]
transition on class_or_interface_type to state [62]
transition on BOOLEAN to state [66]
transition on NUMBER to state [69]
transition on OBJECT to state [65]
transition on ARRAY to state [73]
transition on name to state [75]

-------------------
lalr_state [529]: {
  [interface_member_declarations ::= interface_member_declaration terminators (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [530]: {
  [interface_body ::= lbrace_multiline interface_member_declarations_opt rbrace_multiline (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [531]: {
  [interface_member_declarations ::= interface_member_declarations interface_member_declaration (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR RBRACE PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS DEF INTERFACE IDENTIFIER NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [532]: {
  [extends_interfaces ::= EXTENDS interface_type (*) , {COMMA LBRACE }]
}

-------------------
lalr_state [533]: {
  [top_level_sections ::= top_level_section terminators (*) , {EOF }]
  [modifiers_opt ::= (*) modifiers , {CLASS INTERFACE }]
  [modifier ::= (*) PRIVATE , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [interface_declaration ::= (*) modifiers_opt INTERFACE IDENTIFIER extends_interfaces_opt interface_body , {NEWLINE ENDOFFILE }]
  [top_level_sections ::= (*) top_level_section terminators , {EOF }]
  [modifier ::= (*) PUBLIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [class_declaration ::= (*) modifiers_opt CLASS IDENTIFIER super_opt interfaces_opt class_body , {NEWLINE ENDOFFILE }]
  [top_level_section ::= (*) class_declaration , {NEWLINE ENDOFFILE }]
  [modifiers ::= (*) modifier , {CLASS INTERFACE }]
  [top_level_sections ::= top_level_section terminators (*) top_level_sections , {EOF }]
  [modifier ::= (*) STATIC , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [top_level_sections ::= (*) top_level_section terminators top_level_sections , {EOF }]
  [modifiers_opt ::= (*) , {CLASS INTERFACE }]
  [modifier ::= (*) PROTECTED , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [top_level_section ::= (*) interface_declaration , {NEWLINE ENDOFFILE }]
  [modifiers ::= (*) modifier modifiers , {CLASS INTERFACE }]
  [modifier ::= (*) ABSTRACT , {PUBLIC PROTECTED PRIVATE STATIC ABSTRACT INTERFACE }]
  [top_level_section ::= (*) , {NEWLINE ENDOFFILE }]
}
transition on modifiers_opt to state [20]
transition on class_declaration to state [19]
transition on top_level_sections to state [534]
transition on modifiers to state [17]
transition on interface_declaration to state [16]
transition on PRIVATE to state [15]
transition on top_level_section to state [14]
transition on PROTECTED to state [13]
transition on modifier to state [12]
transition on PUBLIC to state [10]
transition on STATIC to state [11]
transition on ABSTRACT to state [8]

-------------------
lalr_state [534]: {
  [top_level_sections ::= top_level_section terminators top_level_sections (*) , {EOF }]
}

-------------------
lalr_state [535]: {
  [modifiers ::= modifier modifiers (*) , {ARRAY BOOLEAN NUMBER OBJECT STRING VAR CLASS DEF INTERFACE IDENTIFIER }]
}

-------------------
lalr_state [536]: {
  [$START ::= goal EOF (*) , {EOF }]
}

-------------------
lalr_state [537]: {
  [simple_import_declaration ::= IMPORT name (*) , {NEWLINE ENDOFFILE }]
  [import_declaration_with_alias ::= IMPORT name (*) AS IDENTIFIER , {NEWLINE ENDOFFILE }]
  [qualified_name ::= name (*) DOT IDENTIFIER , {DOT AS NEWLINE ENDOFFILE }]
}
transition on DOT to state [45]
transition on AS to state [538]

-------------------
lalr_state [538]: {
  [import_declaration_with_alias ::= IMPORT name AS (*) IDENTIFIER , {NEWLINE ENDOFFILE }]
}
transition on IDENTIFIER to state [539]

-------------------
lalr_state [539]: {
  [import_declaration_with_alias ::= IMPORT name AS IDENTIFIER (*) , {NEWLINE ENDOFFILE }]
}

-------------------
lalr_state [540]: {
  [import_declaration ::= (*) simple_import_declaration , {NEWLINE ENDOFFILE }]
  [import_declarations ::= import_declaration terminators (*) import_declarations , {EOF PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
  [simple_import_declaration ::= (*) IMPORT name , {NEWLINE ENDOFFILE }]
  [import_declarations ::= (*) import_declaration terminators import_declarations , {EOF PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
  [import_declarations ::= import_declaration terminators (*) , {EOF PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
  [import_declaration ::= (*) import_declaration_with_alias , {NEWLINE ENDOFFILE }]
  [import_declarations ::= (*) import_declaration terminators , {EOF PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
  [import_declaration_with_alias ::= (*) IMPORT name AS IDENTIFIER , {NEWLINE ENDOFFILE }]
}
transition on import_declarations to state [541]
transition on import_declaration_with_alias to state [5]
transition on IMPORT to state [3]
transition on import_declaration to state [2]
transition on simple_import_declaration to state [1]

-------------------
lalr_state [541]: {
  [import_declarations ::= import_declaration terminators import_declarations (*) , {EOF PUBLIC PROTECTED PRIVATE STATIC ABSTRACT CLASS INTERFACE NEWLINE ENDOFFILE }]
}

-------------------
------- CUP v0.11a beta 20060608 Parser Generation Summary -------
  0 errors and 0 warnings
  95 terminals, 153 non-terminals, and 324 productions declared, 
  producing 542 unique parse states.
  0 terminals declared but not used.
  0 non-terminals declared but not used.
  0 productions never reduced.
  0 conflicts detected (0 expected).
  Code written to "Parser.java", and "CrystalSymbol.java".
---------------------------------------------------- (v0.11a beta 20060608)
